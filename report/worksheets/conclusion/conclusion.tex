\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Conclusion}{1}{May 25, 2015}{Andreas}{../../}

This thesis tests the hypothesis: \textit{``Language integrated \ac{STM} provides a valid alternative to locking in terms of usability, and provides additional benefits compared to library-based \ac{STM}, when solving concurrent problems in C\#''}. In order to do so an extension to C\#, called \stmname was designed and implemented. \stmname provides language integrated support for \ac{STM} which allows programmers to utilize transactions alongside existing C\# features. The \ac{STM} system powering \stmname was implemented as a C\# library. To implement \stmname, the Roslyn C\# compiler was extended to transform \stmname source code into regular C\# code, which utilizes the aforementioned \ac{STM} library to execute any defined transactions. For each of the concurrency approaches: \stmname, the \ac{STM} library and locking in C\#,  implementations of the Dining Philosophers problem, the Santa Claus problem, a concurrent queue, and a concurrent hashmap were created. These implementations served as the basis for a usability evaluation according to an extended version of the characteristics defined in our previous study\cite{dpt907e14trending}.
%afhænger af problemstillingen af hvilken concurrency model der er bedst -> så derfor godt mere flere concurrency modeller

In order to develop \stmname a set of requirements were defined, detailing how the underlying \ac{STM} system should behave in relation to for example tracking granularity, atomicity level and nesting. Based on the requirements \stmname was designed. The design includes a description of new language constructs as well as a description of modifications to existing language features. A number of \ac{STM} implementations were investigated. Based on this investigation as well as the requirements and design, an \ac{STM} library, utilizing the TL\rom{2} algorithm, was implemented. The \ac{STM} library was tested using a number of unit tests, ensuring that transactions are executed correctly. In order to perform the actual integration of \ac{STM} into C\#, the open source Roslyn C\# compiler was extended. This required a deep knowledge of the Roslyn project and its structure, which initiated an investigation of Roslyn. Due to the limited availability of literature with regards to Roslyn, much of the knowledge obtained in this area was acquired by reading and debugging Roslyn's source code. A number of unit tests were defined for the Roslyn extension, in order to ensure that all \ac{STM} constructs and the integration with the existing language features work correctly. Finally \stmname, the \ac{STM} library and locking in C\# were evaluated according to a number of usability related characteristics, facilitating a conclusion upon the hypothesis.

%The status of \stmname is that it is fully functioning, in relation to the \ac{STM} constructs and the integration with existing C\# language features described in the report\toby{skal det være requirements og stm design istedet?}. This means that using our compiler it is possible to write and run C\# programs with \ac{STM} as concurrency approach.\toby{evt. flyt det op i starten, ved ikke hvor det passer bedst}

%hvad med evaluation? den snakker vi ikke om her, men den tager vi stilling til i hypotesen, så er det vel fint nok?

%Roslyn
%Also as it is not released yet, many examples were outdated, as it had already changed how to perform something. (bedre sætning krævet)

%EXTRA - Måske hav den med et sted hvor den passer (tidligere intro conclusion)
%The language integration abstracts over many of the tedious details associated with library-based \ac{STM}, thus improving the usability, making it easier to write correct concurrent programs in \stmname.

This chapter addresses the problem statement questions and summarizes the evaluation of the characteristics in order to conclude on our hypothesis. %When the term \ac{STM} is used in this chapter, it covers both \stmname and library-based \ac{STM}.

\label{chap:conclusion}

\section{Problem Statement Questions Revisited}
The goal of this master thesis was to investigate the usability of language integrated support for \ac{STM} in C\#, compared to a library-based solution and existing locking features. This section will address the problem statement questions used for structuring our investigation.

Selecting features to an \ac{STM} system for C\# was done by analyzing different approaches to tracking granularity, transactions \& variables, atomicity, side-effects, conditional synchronization, nesting, and opacity. These features determined the requirements for the design. The requirements and the existing language features of C\# were taken into account in the design and integration process of \stmname, identifying how to make an integration encompassing: atomic blocks, transactional variables, parameters \& arguments, conditional synchronization, and nesting. The implementation strategies McRT, TL\rom{2}, and JVSTM were analyzed based on the criteria from the requirements. TL\rom{2} was selected based on its fit with strong atomicity and retry, as well as being well documented. To find out how the Roslyn compiler was structured, a review of whitepapers, blogs, forum posts, and the source code were conducted. This resulted in a description of Roslyns compiler phases, syntax tree, and \ac{API}. This knowledge allowed us to extend Roslyn to encompass the features of \stmname, by modifying its lexer, parser, syntax tree and symbols. Additionally, the Roslyn compiler was extended with a transformation phase, transforming \stmname's constructs to ordinary C\# code, allowing the remaining compilation phases to be reused.

\section{Hypothesis Revisited}
With a functioning \stmname language, library-based \ac{STM}, and locking in C\#, we evaluated the concurrency approaches based on cases representing different aspects of concurrency. Based on this evaluation, we conclude on the hypothesis in \bsref{subsec:final_conclusion}.

\ac{STM} has a more implicit degree of concurrency than locking, as synchronization details are abstracted away. This also makes library-based \ac{STM} more fault restrictive than locking as synchronization details are handled correctly by the underlying \ac{STM} system, hindering potential errors known from locking e.g. deadlocks. \stmname is even more fault restrictive, since static analysis identifies a number of errors. Both locking and \ac{STM} use shared memory for communication, and require the programmer to specify the scope of synchronization reducing their readability and writability.

The optimistic nature of \ac{STM} relies on conflicts being uncommon,  correcting them if they occur. The correction results in aborting a transaction, and running it again. Thus all effects occurring in transactions must be able to be discarded in case of an abort. This is however not the case for irreversible actions, decreasing the usability of \ac{STM}, as the programmer is required to know which operations cannot be used in transactions.

From the programmer's point of view \stmname does not change the type of transactional variables, which increases its readability. This is a benefit compared to the library-based \ac{STM} approach, which requires transactional variables to be wrapped in \bscode{TMVar} objects. The programmer can for example compare two transactional variables directly in \stmname, where in the \ac{STM} library she is required to compare the \bscode{Value} properties of the \bscode{TMVars} instead. Furthermore \stmname and the \ac{STM} library require data types, including collections, to be build using transactional variables which lowers the writability of the two \ac{STM} based approaches.  % Compared to locking, the usability of the two approaches are similar in regards to data types.   %pass the value of a transactional variable directly as an argument for a non-transactional parameter of the same type

\stmname allows the programmer to define transactional variables by supplying the \bscode{atomic} modifier. As a consequence an array of transactional variables cannot be defined in \stmname. Instead the programmer must either wrap each element in an object with a transactional field, employ an immutable list, or use a specialized \ac{STM} list that tracks elements internally. These workarounds do however reduce both readability and writability, which negatively affects the usability of \stmname.

\stmname integrates \ac{STM} at a level similar to that of locking in C\#, providing a number of benefits compared to library-based \ac{STM}. The \ac{STM} related keywords supplied by \stmname increases its readability as the intent stands out clearly. However, simplicity is  reduced, as special keywords add complexity to the language. The syntax of \stmname is improved compared to library-based \ac{STM}, as boilerplate syntax is abstracted away. This is a benefit to \stmname compared to library-based \ac{STM}.

The declarative synchronization approach in \ac{STM} provides high simplicity, a high level of abstraction and high expressivity. Locking requires the programmer to explicitly control synchronization details, which is hard to get right. \ac{STM} on the other hand handles synchronization as long as the critical regions are specified, which improves usability. Additionally \stmname provides static analysis, capable of identifying errors in the code, a feature not present in the \ac{STM} library.

The locking constructs provided by C\#  can be  combined to handle different scenarios which improves the orthogonality. However the risk of deadlocks when combining locks reduces the orthogonality. \ac{STM} removes the issue of deadlocks, and allows transactions to be nested, which is highly orthogonal. A major caveat is, that \ac{STM} cannot be combined with irreversible actions, keeping the orthogonality, level of abstraction and expressivity of the \ac{STM} based approaches from reaching their potential, impacting both readability and writability. Library-based \ac{STM} supplies implicit conversion from an \ac{STM} object to its wrapped value. However certain cases, e.g. comparisons, require explicitly accessing the \bscode{Value} property of the \ac{STM} object. \stmname does not have the type mismatch between regular types and the corresponding \ac{STM} types. Due to this, no extra actions must be taken when retrieving the value of a transactional variable. This provides a benefit to \stmname over library-based \ac{STM}, as it improves writability.

\subsection{Final Conclusion}\label{subsec:final_conclusion}
Based on the above findings we conclude that language integrated \ac{STM} provides a valid alternative to locking when solving concurrency problems. This is based on it being evaluated as having more implicit concurrency, being more fault restrictive, being simpler, having a level of abstraction, expressivity, readability, and writability. Locking does however have higher orthogonality due to \ac{STM}’s problems combining with irreversible actions and existing data structures, reducing the applicability of \stmname.

Furthermore, \stmname provides additional benefits over language integrated \ac{STM}. This is based on being evaluated as equal in implicit concurrency and optimism, while having improved readability and writability based on a less intrusive syntax design, higher simplicity, orthogonality, level of abstraction, and expressivity.

\worksheetend