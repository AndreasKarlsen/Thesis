\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Conclusion}{1}{May 25, 2015}{Andreas}{../../}

\toby[i]{Skal sikre tiden der skrives i er korrekt (i intro teksten her}
The product developed in this thesis is \stmname, which is an integration of the concurrency model \ac{STM} into C\# as a language feature.\toby{ved ikke om language feature kan hænge på her måske ændre til noget lignende:, and it enables programmers to use \ac{STM} as a language feature} The integration of \ac{STM} is motivated by the need for utilizing increasing number of CPU cores, as it provides another concurrency approach that avoids many of the risks associated with locking.\toby{En anden grund kan være der ikke er mange STM implementeringer til C\# (men det har vi vel ikke med i rapporten et sted)}
%afhænger af problemstillingen af hvilken concurrency model der er bedst -> så derfor godt mere flere concurrency modeller

In order to develop \stmname, a number of topics were investigated and a number of decisions were taken. As there exists many variations of \ac{STM}, a set of requirements were defined which explain exactly how the \ac{STM} system of \stmname should behave in relation to e.g. tracking granularity, atomicity level and nesting level. Furthermore, the design of \ac{STM} constructs and how they are integrated in relation to existing constructs in C\# were defined. This includes the syntax but also considerations such as whether a transactional type should be implemented as a special type or a regular type with an atomic keyword modifier, where we have chosen the latter. Based on the requirements and \ac{STM} design an \ac{STM} implementation was build, specifically an \ac{STM} library, which \stmname also uses internally as \ac{STM} system. To build this library an investigation into a number of \ac{STM} algorithms was performed in order to learn how to implement an \ac{STM} system, and one was chosen based on a number of implementation criteria. In order to ensure that the \ac{STM} library performs correctly, testing was performed. Additionally, to perform the actual integration of \ac{STM} into C\#, the open source Roslyn C\# compiler was extended. This required a deep knowledge of the Roslyn project and its structure, which initiated an investigation of Roslyn. However at the time of writing little literature on other than the API side of Roslyn exists, which resulted in much manual inspection and debugging of the source code. Testing was also employed in the Roslyn extension, in order to test that all \ac{STM} constructs and the integration with the existing language features works correctly.

The status of \stmname is that it is fully functioning, in relation to the \ac{STM} constructs and the integration with existing C\# language features described in the report\toby{skal det være requirements og stm design istedet?}. This means that using our compiler it is possible to write and run C\# programs with \ac{STM} as concurrency approach.\toby{evt. flyt det op i starten, ved ikke hvor det passer bedst}

%hvad med evaluation? den snakker vi ikke om her, men den tager vi stilling til i hypotesen, så er det vel fint nok?

%Roslyn
%Also as it is not released yet, many examples were outdated, as it had already changed how to perform something. (bedre sætning krævet)

%EXTRA - Måske hav den med et sted hvor den passer (tidligere intro conclusion)
%The language integration abstracts over many of the tedious details associated with library-based \ac{STM}, thus improving the usability, making it easier to write correct concurrent programs in \stmname.

This chapter will address the problem statement questions and summarize the evaluation of the characteristics in order to conclude on our hypothesis. When the term \ac{STM} is used in this chapter, it covers both \stmname and library-based \ac{STM}. 

\label{chap:conclusion}

\section{Problem Statement Questions}
The goal of this master thesis was to investigate the usability of language integrated support for \ac{STM} in C\#, compared to a library-based solution and existing locking features. The hypothesis formalized this goal, and the problem statement questions structured our investigation.

Selecting features to an \ac{STM} system for C\# was done by analyzing different approaches to: Tracking granularity, transactions \& variables, atomicity, side-effects, conditional synchronization, nesting, and opacity. These features determined the requirements for the design. The requirements and the existing language features of C\# was taken into account in the design and integration process of \stmname, identifying how to make a seamless integration encompassing: atomic blocks, transactional variables, parameters \& arguments, conditional synchronization, and nesting. The implementation strategies McRT, TL\rom{2}, and JVSTM were analyzed based on the criteria from the requirements. TL\rom{2} was selected based on its fit with strong atomicity and retry, as well as being well documented. To find out how the Roslyn compiler was structured, a review of whitepapers, blogs, forum posts, and the source code was conducted. This resulted in a description of Roslyns compiler phases, syntax tree, and \ac{API}. This knowledge allowed us to extend Roslyn to encompass the features of \stmname, by modifying its lexer, parser, syntax tree and symbols. Additionally, the Roslyn compiler was extended with a transformation phase, transforming \stmname's constructs to ordinary C\# code, allowing the remaining compilation phases to be reused.

\section{Hypothesis}
With a functioning \stmname language, library based \ac{STM}, and locking in C\#, we evaluated the concurrency approaches based on cases representing different aspects of concurrency. Based on this evaluation, we conclude on the hypothesis: 

\paragraph{Hypothesis} Language integrated \ac{STM} provides a valid alternative to locking in terms of usability, and provides additional benefits compared to library based \ac{STM}, when solving concurrency problems in C\#.\andreas{If we change this, we must change Preliminary Knowledge and Evaluation} 

\ac{STM} have a more implicit degree of concurrency than locking, as synchronization details are abstracted away. This also makes \ac{STM} more fault restrictive than locking as synchronization details are handled correctly by the underlying \ac{STM} system, hindering potential errors known from locking e.g. deadlock. Both locking and \ac{STM} uses shared memory for communication, and require the programmer to specify the scope of synchronization.

The optimistic nature of \ac{STM} relies on conflicts being uncommon,  correcting them if they occur. The correction results in aborting a transaction, and running it again. Thus all effects occurring in transactions must be able to be discarded in case an abort occurs. This is however not the case for so called irreversible actions such as \ac{IO},  decreasing the usability of \ac{STM}, as the programmer is required to know of operations which cannot be used in transactions.

From the point of view of the programmer \stmname does not change the type of transactional variables, which increases  its readability. This is a benefit compared to the library based \ac{STM} approach, which requires transactional variables to be wrapped in a \bscode{TMVar} object. Therefore, the programmer can, for example,  compare two transactional variables directly in \stmname where the \ac{STM} library requires comparison between the \bscode{TMVar} object's \bscode{Value} property instead. Furthermore \stmname and the \ac{STM} library requires data types, including collections, to be build using transactional variables which lowers the writability of the two \ac{STM} based approaches.  % Compared to locking, the usability of the two approaches are similar in regards to data types.   %pass the value of a transactional variable directly as an argument for a non-transactional parameter of the same type

\stmname allows the programmer to define transactional variables by supplying the \bscode{atomic} modifier. As a consequence an array of transactional variables cannot be defined in \stmname. Instead the programmer must either: wrap each element in an object with a transactional field, employ an immutable list, or use a specialized \ac{STM} list that tracks elements internally. These workarounds does however reduce both readability and writability. 

\stmname integrates \ac{STM} at a level similar to that of locking in C\#, providing a benefit compared to library based \ac{STM}. The \ac{STM} related keywords supplied by \stmname increases its readability as the intent stands out clearly. However, simplicity is  reduced, as special keywords adds complexity to the language. The syntax of \stmname is improved compared to library based \ac{STM}, as boilerplate syntax is abstracted away. This is a benefit to \stmname compared to library based \ac{STM}. 

The declarative synchronization approach in \ac{STM} provides high simplicity, a high level of abstraction and high expressivity. Locking requires the programmer to explicitly control synchronization details, which is hard to get right. \ac{STM} on the other hand handles synchronization as long as the critical regions are specified, which improves usability. Additionally \stmname provides static analysis, capable of identifying errors in the code, a feature not present in the \ac{STM} library. 

The locking constructs provided by C\#  can be  combined to handle different scenarios which improves the orthogonality. However the threat of deadlocks when combining locks reduces the orthogonality significantly. \ac{STM} removes the issue of deadlocks, and allows transactions to be nested, which is highly orthogonal. A major caveat is, that \ac{STM} cannot be combined with irreversible actions, keeping the orthogonality, level of abstraction and expressivity from reaching its potential, impacting both readability and writability. Library based \ac{STM} supplies implicit conversion from an \ac{STM} object to its wrapped value. However certain cases,  e.g. comparisons, require explicitly accessing the \bscode{Value} property of the \ac{STM} object. From the point of view of the programmer, \stmname does not have the type mismatch between regular types and the corresponding \ac{STM} types. Due to this, no extra actions must be taken when retrieving the value of a transactional variable. This provides a benefit to \stmname over library based \ac{STM}, as it improves writability.

Conclusively language integrated \ac{STM} provides a valid alternative to locking when solving concurrency problems. This is based on being evaluated as having more implicit concurrency, being more fault restrictive, being simpler, having higher orthogonality, level of abstraction, expressivity, readability, and writability.

Furthermore, \stmname provides additional benefits over language integrated \ac{STM}. This is based on being evaluated as equal in implicit concurrency, fault restrictiveness, and optimism. Additionally It is evaluated to have better readability and writability based on not requiring change of types, a less intrusive syntax design, higher simplicity, orthogonality, level of abstraction, and expressivity.

\worksheetend