\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Conclusion}{1}{May 25, 2015}{Andreas}{../../}
Driven by the motivation of utilizing the increasing amount of \ac{CPU} cores, we have created \stmname, which integrates \ac{STM} into C\# as a language feature. This enables concurrent calculations without introducing many of the risks in shared-memory concurrency. The language integration gives C\# users a first class \ac{STM} experience thus improving the usability, making it easier to write correct concurrent programs in C\#.  

This chapter will answer the problem statement questions, summarize the evaluation of the characteristics in order to conclude on our hypothesis. When the term \ac{STM} is used in this chapter, it covers both \stmname and library based \ac{STM}. 

\label{chap:conclusion}

\section{Problem Statement Questions}
The goal of this master thesis was to investigate the usability of language integrated support for \ac{STM} in C\#, compared to a library based solution and existing locking features. Our hypothesis formalize this goal, and the problem statement questions structured our investigation.

Selecting features to a \ac{STM} system for C\# was done by analyzing different approaches to: Tracking granularity, transactions \& variables, atomicity, side-effects, conditional synchronization, nesting, and opacity. These features determined the requirements for the design. The requirements and the existing language features of C\# was taken into account in the design and integration process, identifying how to make a seamless integration with: Blocks \& variables, parameters \& arguments, conditional synchronization, and nesting. The implementation strategies McRT, TL\rom{2}, and JVSTM was analyzed based on criteria from the requirements. TL\rom{2} was selected based on its fit with strong atomicity and retry, as well as being well documented. To find out how the Roslyn compiler was structured, a review of whitepapers, blogs, forum posts, and the source code was conducted. This resulted in a description of Roslyns compiler phases, syntax tree, and \ac{API}. This knowledge allowed us to extend Roslyn to encompass the features of \stmname, by modifying its lexer, parser, and syntax tree. Additionally, a transformation of the syntax tree was performed, to transform \stmname constructs to ordinary C\#, allowing us to reuse the rest of the compilation phases.

\section{Hypothesis}
With a functional \stmname language, library based \ac{STM}, and locking in C\#, we evaluated the concurrency approaches based on cases representing different aspects of concurrency. Based on this evaluation, this chapter describes how we answered our problem statement questions and the conclude on the hypothesis: 

\paragraph{Hypothesis} Language integrated \ac{STM} provides a valid alternative to locking in terms of usability, and provides additional benefits compared to library based \ac{STM}, when solving concurrency problems in C\#.\andreas{If we change this, we must change Preliminary Knowledge and Evaluation} 

\ac{STM} have a more implicit degree of concurrency than locking, as synchronization details are abstracted away. This also makes \ac{STM} more fault restrictive than locking as synchronization details are handled correctly by the underlying \ac{STM} system. This hinder potential errors known from locking e.g. deadlock. Both locking and \ac{STM} uses shared memory for communication, and still require the programmer to specify the scope of synchronization.

The optimistic nature of \ac{STM} makes it assume correct execution, and correcting errors if they occur. The correction results in aborting a transaction, and running it again. Thus all effects occurring inside of a transaction, cannot persist after an abortion. This decreases the usability of \ac{STM}, as the programmer needs knowledge of operations which cannot be used inside transactions.

\stmname keeps the original type, which increases the readability. This is a benefit compared to the library based \ac{STM}, as the type does not have to be wrapped in a \bscode{TMVar}. Compared to locking, the usability of the two approaches are similar in regards to data types. 

In \stmname, changes to an array containing transactional types cannot be tracked. To track changes in an array, the programmer can: Use an \bscode{ImmutableList,} wrap the elements in an atomic object, or use a special \ac{STM} list provided in a library. These workaround does however reduce both readability and writability. 

The keywords in \stmname increases the readability as the intent stands out clearly. The simplicity is however reduced, as special keywords adds complexity since it requires grasping new concepts. The syntax of \stmname is improved compared to library based \ac{STM}, as boilerplate syntax is abstracted away. This is a benefit to \stmname over library based \ac{STM}, and it provides the same level of language integration as locking. The possibility of passing \bscode{atomic} variables as non-atomic arguments, and vice versa, also provides a clear benefit of \stmname over library based \ac{STM}. 

The declarative synchronization approach in \ac{STM} gives high simplicity, level of abstraction and expressivity. Compared to locking, where the programmer explicitly has to control synchronization details, which is hard to get right, \ac{STM} handles synchronization if the critical regions are specified. This gives better usability to \ac{STM}. \stmname provide static analysis, which can identify some erroneous code. This benefits \stmname over library based \ac{STM}.

The locking constructs can be used and combined to handle different scenarios. This makes locks orthogonal, albeit the thread of deadlocks when combining locks reduces the orthogonality. \ac{STM} removes the issue of deadlocks, and allows transactions to be nested, which is highly orthogonal. A major caveat is, that \ac{STM} cannot be combined with irreversible actions, keeping the orthogonality, level of abstraction and expressivity from reaching its potential, impacting both readability and writability. Library based \ac{STM} relies on implicit conversion and explicit access to the \bscode{Value} property of the transactional variables for certain usage e.g. comparisons. As \stmname does not have the type mismatch between regular types and the corresponding \ac{STM} types, these usages can be done normally. This provides a benefit to \stmname over library based \ac{STM}, as it gives improved writability.

\andreas[inline]{Giver Level of abstraction, alene noget om usability som vi ikke tidligere har talt om?}

Conclusively language integrated \ac{STM} provides a valid alternative to locking when solving concurrency problems. This is based on being evaluated as having more implicit concurrency, being more fault restrictive, being simpler, having higher orthogonality, level of abstraction, expressivity, readability, and writability.

Furthermore, \stmname provides additional benefits over language integrated \ac{STM}. This is based on being evaluated as equal in implicit concurrency, fault restrictiveness, and optimism. It is evaluated to have better readability and writability based on not requiring change of types, a less intrusive syntax design, higher simplicity, orthogonality, level of abstraction, and expressivity.

\worksheetend