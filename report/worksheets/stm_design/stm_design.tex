\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{STM Designed for C\#}{0}{Februar 10, 2015}{}{../../}
This chapter describes the process of designing an \ac{STM} system for C\#. \bsref{sec:stm_requirements} highlights the requirements for the \ac{STM} system while \bsref{sec:stm_design} describes the \ac{STM} systems design. Implementation details are described in \bsref{chap:implementation}.
\label{chap:stm_design}
\section{Requirements}
\label{sec:stm_requirements}
\kasper[inline]{General stuff. Atomic block. Language support}
\kasper[inline]{Purpose}
In this section we analyze what properties the design of an \ac{STM} system requires in order to integrate with C\#.
\kasper[inline]{Refer to work last semester}
\andreas[inline]{Should we have an analysis of C\# to see how we should design the STM system?}
\kasper[inline]{State that requirements/design is based on criteria?}
\subsection{Transactions \& Variables}
\label{subsec:rec_transactions_variables}
%Trans keyword
%Atomic block
%Read outside transactions
%No write outside transactions
As described in \bsref{sec:stm_keyconcepts_example} a \ac{STM} system must offer some way of defining a transaction scope. As \stmnamesp is to be a language integrated \ac{STM} system, C\# must be extended with syntax for specifying a transaction scope.

A \ac{STM} system abstracts away many of the details of how synchronization is achieved. Simply applying transactions over a number of C\# variables provides a high level of abstraction but also hides the impact of synchronization. Having the programmer specify what variables should be tracked by the \ac{STM} system ensures that she is aware of what variables the \ac{STM} is managing. Explicitly reasoning about what variables are to be synchronized can assist the programmer in gauging the performance of a transaction as well as better understanding the execution of transactions. Both areas which usability studies\cite{rossbach2010transactional}\cite{pankratius2009does} has found to be problematic for some. As with defining transaction scopes C\# must be extended with syntax for marking variables for synchronization inside transactions. We call a variable marked for use in transactions a transactional variable.

\stmnamesp must not be overly restrictive as this will limit its applicability. To that end the \ac{STM} system must allow reads from transactional variables to occur both inside and outside transactions. 

For writes to transactional variables a choice exists between allowing and disallowing writes from outside transactions. Disallowing writes from outside transaction will ensure that non-transactional access can not interfere with transactional access but will hamper the usability of the \ac{STM} system. Allowing writes from outside transactions increases the complexity of the implementation as any conflicts such writes create must be detected and resolved by the \ac{STM} system. As allowing writes from outside transactions provides the best usability \stmnamesp must provides support for such writes in addition to writes from inside transactions. This requirement is closely related to the choice between strong and weak atomicity discussed in \bsref{sec:design_strong_weak_atomicity}.

\subsection{Strong or Weak Atomicity}
\label{sec:design_strong_weak_atomicity}
The atomicity guarantee provided by \ac{STM} systems varies, depending on the semantics provided. In \cite{blundell2006subtleties} Blundell et al. define two levels of atomicity:
%
\begin{defn}\label{def:strong_atomicity}
\emph{[...] strong atomicity to be a semantics in which transactions execute atomically
with respect to both other transactions and non-transactional code.}
\end{defn}
%
\begin{defn}\label{def:weak_atomicity}
\emph{[...] weak atomicity to be a semantics in which transactions are atomic only with respect to other transactions.}
\end{defn}

Strong atomicity provides non-interference and containment between transactional and non-transactional code, where as weak atomicity does not. As an example, using the \bscode{Car} class defined in \bsref{lst:atomicity}, having the \bscode{KmDriven} setter called from one thread, while another thread is calling the \bscode{Drive} method, strong and weak atomicity yields different results. Under strong atomicity, all changes made inside the \bscode{atomic} block at line 12, are isolated from non-transactional code. Additionally, changes made from the setter is isolated from inside the atomic block. The result is, that if the setter is called in the middle of the \bscode{Drive} method, there will be a conflict which must be resolved. 

If only weak atomicity is guaranteed, given the same scenario, the change made through the setter, would be visible inside the atomic block. Thus shared memory between transaction and non-transactional code can lead to race conditions.
%

\begin{lstlisting}[label=lst:atomicity,
  caption={Level of Atomicity},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Car {
    private int _kmDriven;
    public int KmDriven {
      get {
        return _kmDriven;
      }
      set {
        _kmDriven = value;
      }
    }
    public void Drive (int km) {
      atomic {
        _kmDriven += km;
      }
    }
  }
\end{lstlisting}

% TODO: Decide if we want the manual written properties or the auto-implemented ones.
%
%\begin{lstlisting}[label=lst:atomicity,
%  caption={Level of Atomicity},
%  language=Java,  
%  showspaces=false,
%  showtabs=false,
%  breaklines=true,
%  showstringspaces=false,
%  breakatwhitespace=true,
%  commentstyle=\color{greencomments},
%  keywordstyle=\color{bluekeywords},
%  stringstyle=\color{redstrings},
%  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block
%
%  class car {
%    public int KmDriven { get; set; }
%    public void Drive (int km) {
%      atomic {
%        KmDriven += km;
%      }
%    }
%  }
%\end{lstlisting}


\subsubsection{Problems with Weak-atomicity}
There exists many issues, harris et al have composed a list here, but there exists many more.

\paragraph{Unambiguous data races between transactional and non-transactional code}
Anomalies Common with Lock-Based Synchronization

\paragraph{Granularity problems that occur when the data managed by the TM implementation is coarser than the program variables being accessed}
Anomalies Due to Coarse Write Granularity

\paragraph{Accesses by zombie transactions in TMs that do not provide opacity}
Anomalies Due to Zombie Transactions

\paragraph{privatization and publication idioms}
Anomalies Due to Privatization and Publication

\subsubsection{Problems with Strong-atomicity}
It is more attractive from the point of view of defining the \ac{STM} semantics. It does however not solve all problems.

\subsubsection{Discussion}
We chose Strong atomicity due to...
 
\subsection{Conditional Synchronization}
\label{sec:req_conditional}
To be a valid alternative to existing C\# synchronization mechanism a \ac{STM} system must be broadly applicable. This requires support for conditional synchronization so that \ac{STM} can be employed in well know scenarios such as shared buffers and other producer consumer setups\cite[p. 128]{tanenbaum2008modern}. \bsref{chap:stm_key_concepts} discusses the \bscode{retry} and \bscode{orElse} constructs proposed in \cite{harris2005composable} for conditional synchronization and composition of alternatives. Supporting such constructs in C\# will increase the applicability of the \ac{STM} system.

Our previous work in \cite{dpt907e14trending} included a implementation of $k$-means clustering algorithm\cite[p. 451]{dataminingconceptsandtechniques} in the functional programming language Clojure. Clojures contains a language integrated \ac{STM} implementation which does not support constructs such as \bscode{retry} and \bscode{orElse}. As a result the implementation requires the use of condition variables and busy waiting in scenarios where the \bscode{retry} construct could have been employed\cite{duffy2010stmnet}.  As such, supplying \bscode{retry} and \bscode{orElse} constructs in C\# will allow for simpler conditional synchronization without the need for busy waiting thereby increasing the simplicity and level of abstraction in such scenarios.
\andreas{A disadvantage is that the complexity of using STM is increased. Albiet the retry and orelse constructs are optional}
\subsection{Nesting}
The traditional \ac{TL} approach to concurrency has issues with composability due to the threat of deadlocks\cite[p. 58]{sutter2005software} when composing lock based code. \ac{STM} attempts to mitigate this issues by removing the threat of deadlock, and allowing transactions to nest. Nesting can occur both lexically and dynamically\cite[p. 1]{kumar2011hparstm}\cite[p. 42]{harris2010transactional}\cite[p. 2081]{herlihy2011tm}. \bsref{lst:stm_nested_transactions} shows a example a lexically nested transaction while \bsref{lst:stm_nested_transactions_real} shows a example of dynamically nested transactions. Here the withdraw and deposit methods on the accounts are themselves defined using transactions.

\begin{lstlisting}[label=lst:stm_nested_transactions,
  caption={Lexically nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		x = 7;
		atomic{
			y = 12;		
		}
	}
       
\end{lstlisting}

\begin{lstlisting}[label=lst:stm_nested_transactions_real,
  caption={Dynamically nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		var amount = 200;
		account1.withdraw(amount);
		account2.deposit(amount);
	}
       
\end{lstlisting}

An \ac{STM} system for C\# must support nesting of transaction as this will mitigate the before mentioned issues and be a valid alternative to the existing locked based synchronization mechanisms. A more in depth description of the composability problems of the \ac{TL} concurrency model and nesting of transactions can be found in \cite{dpt907e14trending}.


%Flat, open, closed.

\section{Design}
\label{sec:stm_design}
This section describes the design of \stmnamesp based on the requirements defined in \bsref{sec:stm_requirements}.

As described in \bsref{subsec:rec_transactions_variables} \stmnamesp must supply language integrated support definition of transaction scopes as well as declaration of transactional. For this purpose \stmnamesp extends C\# with a \bscode{atomic} keyword. The atomic keyword will serve as both a statement denoting a transaction scope as well a modifier applicable to the definition of variables. \bsref{label=lst:stm_atomic_syntax}, which is a modified version of the race condition example from our previous study\cite[p. 23]{dpt907e14trending}, presents a example of the syntax extension. On line 6 the transactional variable number is defined and assigned a initial value of 10. The main method defines and starts two threads. \bscode{t1} checks if the value of number is equal to 10 and assigns \bscode{number} times 3 to the variable if the condition is true. These operations are executed as a transaction defined by the \bscode{atomic} keyword and associated block on line 11. \bscode{t2} simply assigns 20 to number inside a transaction defined on line 17. In this example \stmnamesp removes the race conditions associated with \bscode{t2} changing the value of \bscode{number} between the read on line 12 and the read on line 13. In the case such a change occurs the \ac{STM} system of \stmnamesp will abort and retry on of the implicated transactions.
 
\begin{lstlisting}[label=lst:stm_atomic_syntax,
  caption={Transaction Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  using System.Threading;
  
  public class RaceCondition
  {
      public static atomic int number = 10;
  
      public static int Main(string[] args)
      {
          Thread t1 = new Thread ( () => {
              atomic{
                  if (number == 10 )           
                      number = number * 3;
              }
           });
          Thread t2 = new Thread( () => {
              atomic{
                  number = 20;
              }
          });
          t1.Start(); t2.Start();
          t1.Join(); t2.Start();
          int result;
          atomic{
          	result = number;          
          }
          Console.WriteLine("Result is: "+result);
          return 0;
      }
  }
\end{lstlisting}

As described in \bsref{subsec:rec_transactions_variables} and \bsref{sec:design_strong_weak_atomicity} \stmnamesp must provide strong atomicity as well as allow reads and writes to occur from outside transactions. As a result, reads and writes occurring from outside transactions will be accounted for when validating transactions. With that ind mind the previous example can be slightly simplified to the example presented in \bsref{label=lst:stm_atomic_syntax_simplified}. The atomic block on line 17 of the previous example has been removed. As the atomic block only contains a single write it serves no purpose as the write is still tracked by the \ac{STM} system without atomic block. The atomic block on line 24 of the previous example can also be removed as the read can safely be performed from outside a transactions.

\begin{lstlisting}[label=lst:stm_atomic_syntax_simplified,
  caption={Transaction Syntax Simplified},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  using System.Threading;
  
  public class RaceConditionSimple
  {
      public static atomic int number = 10;
  
      public static int Main(string[] args)
      {
          Thread t1 = new Thread ( () => {
              atomic{
                  if (number == 10 )           
                      number = number * 3;
              }
           });
          Thread t2 = new Thread( () => {
                  number = 20;
          });
          t1.Start(); t2.Start();
          t1.Join(); t2.Start();
          Console.WriteLine("Result is: "+number);
          return 0;
      }
  }
\end{lstlisting}
Allowing access to transactional variables from outside transactions dispenses with the need for defining a transaction whenever only a single read or write is to be performed, thereby simplifying these cases. The atomic block is then employed only when multiple operations are to be performed as a single atomic step.  

\subsection{Conditional Synchronization}
As described in \bsref{sec:req_conditional} \stmnamesp support conditional synchronization via the \bscode{retry} and \bscode{orElse} constructs. To that end \stmnamesp extends C\# with a \bscode{retry} statement that can only be used inside atomic blocks as well as allowing zero to many \bscode{orElse} blocks to be associated with a atomic block. Much like catch clauses are associated with a \bscode{try} statement in many C like languages, including C\#. \bsref{lst:stm_atomic_syntax_retry} presents the \bscode{Dequeue} method from a transactional queue. \bscode{Dequeue} consists of a atomic block, defined on line 11, performing the dequeue operation as a single atomic step.

 The queue blocks if \bscode{Dequeue} is called on an empty queue.


\begin{lstlisting}[label=lst:stm_atomic_syntax_retry,
  caption={Retry Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  
  public class Queue<T>
  {
  	private atomic Node _head = null;
  	private atomic Node _tail = null;
  	private atomic int _size = 0;

  	public T Dequeue()
  	{
  		atomic{
  		
  			if (_head == null)
  				retry;

  			var oldHead = _head;

  			_head = _old.Next;
  			if (_head == null)
  				_tail = null;
  			
  			_size--;

  			return oldHead.Value;
  		}
  	}
  	
  	...
  }
\end{lstlisting}

\section{Syntax design}


%atomic {
%  if ( booleanexpression ) {
%  ...
%}
%
%vs
%
%atomic( booleanexpression) {
%  ...
%}
%
%    atomic {
%      if(_queue.IsEmpty())
%        retry;
%      return _queue.Dequeue();
%    } orElse {
%      if(_queue2.IsEmpty())
%        retry;
%      return _queue2.Dequeue();
%    } orElse {
%      if(_queue3.IsEmpty())
%        retry;
%      return _queue3.Dequeue();
%    }
%    
%vs
%
%    atomic (_queue.IsEmpty()){
%      return _queue.Dequeue();
%    } orElse (_queue2.IsEmpty()){
%      return _queue2.Dequeue();
%    } orElse (_queue3.IsEmpty()){
%      return _queue3.Dequeue();
%    }
%    
%vs
%    atomic {
%      match (_queue.size()) with
%      | 3 -> _queue.dequeue();
%      | 2 -> _queue.peek();
%      | default -> retry;
%      }
         
         
%	atomic keyword for methods and properties
% public atomic void drive (int km) { ... }
% public atomic int wheels { get; set; }

\worksheetend