\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Design and Integration}{0}{Februar 10, 2015}{}{../../}
This chapter describes the considerations \& design decisions of \stmname, the integration with existing language features, as well as \stmname's syntax \& semantics. The design of \stmnamesp impacts the way it can be integrated with C\#. Thus we make the design adhere to the requirements made in \bsref{sec:stm_requirements}, while integrating seamlessly with existing language features. The decisions made in this chapter, will be the requirements for the implementation of \stmname, which will be described in \bsref{chap:implementation}.

We introduce the atomic block and transactional variables in \bsref{sec:stm_design}. The different kinds of parameters and their integration with transactions is described in \bsref{sec:parameter_design}. This is followed by an example of the new syntax, demonstrated in \bsref{sec:example_design}. The \bscode{retry} and \bscode{orelse} keywords are introduced in \bsref{sec:sync_design} for supporting conditional synchronization. \bsref{sec:nesting_design} shows how \stmnamesp supports nesting of transactions. Finally a summary of the design requirements described in this chapter is given in \bsref{sec:summary_design}.

Throughout this chapter, we use Extended Backus-Naur Form. It is used for descriptions of the proposed syntax extensions, with ? signaling 0 or 1 occurrences and + signaling 0 or more occurrences. Parentheses are used for grouping: ( item1, item2 ). Items formatted as \bscode{non-term} are non terminals, usually keywords, while items formatted as $terminal$ are terminals. 
\label{chap:stm_design}

\section{Transactional Block \& Variables}\label{sec:stm_design}
As described in \bsref{subsec:rec_transactions_variables} \stmnamesp must supply language integrated support for defining transaction scopes as well as declaration of transactional variables. For this purpose \stmnamesp extends C\# with the \bscode{atomic} keyword. The \bscode{atomic} keyword will serve as both a statement denoting a transaction scope as well as a modifier applicable to the declaration of variables. 

\subsection{Transactional Block}
The declaration of a transaction takes the format \bscode{atomic} \{ $S$ \}, where $S$ is the general class of C\# statements. Any assignments to transactional variables inside an atomic block will be perceived as executed in one atomic step by other transactions and non-transactional code.

\subsection{Transactional Field}
The declaration of a transactional field takes the format:

$field$-$modifiers$ $type$ $name$ = $initial$-$value$ ( , $name$ = $initial$-$value$ )+ ; \\
$field$-$modifiers$ $type$ $name$ ( , $name$ )+ ;

where $field$-$modifiers$ includes the new \bscode{atomic} keyword as well as existing C\# modifiers such as \bscode{public}, \bscode{private} and \bscode{static}. The $field$-$modifiers$ {readonly} and \bscode{const} are not included, since their unchangeable nature makes tracking them in a \ac{STM} system pointless.

The $type$ can be any existing or user-defined type including the \bscode{dynamic} keyword. The calculation of \bscode{initial-value} follows the same rules as standard C\# field initializers\cite[p. 40]{sestoft2011c}.

\bsref{lst:design_transactional_fields} presents an example of atomic field declarations.

\begin{lstlisting}[label=lst:design_transactional_fields,
  caption={Local Transactional Variable},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  private atomic string s = "abc";
  public atomic static int x, y, z;
\end{lstlisting}

\subsection{Transactional Properties}
C\# facilitates a language feature which eases the encapsulation of fields typically used in \ac{OOP}. The feature is known as properties, and can be in an automatic or a manual form. The formats in mentioned order are\cite[p. 52]{sestoft2011c}:

$field$-$modifiers$ $type$ $name$ \{$access$-$modifier$? get; $access$-$modifier$? set; \}
$method$-$modifiers$ $type$ $name$ $\{$ get $get$-$body$ set $set$-$body$ $\}$

where $field$-$modifiers$ includes the new \bscode{atomic} keyword, and $method$-$modifiers$ does not. This is the only change to properties in C\#, and the normal rules of property usage still applies, as defined in \cite[p. 52]{sestoft2011c}.

The manual property lets the programmer specify a backing field manually, allowing him to specialize the functionality of the getter and setter, i.e. used for implementing the observer pattern. The automatic properties generate a backing field automatically, but the getter and setter cannot have specialized functionality. 

Atomic automatic properties simplifies the implementation whenever the property serves as a simple getter and setter. An example of such a property is shown in \bsref{lst:auto_atomic_property}. If the programmer wishes to supply additional logic for the get and set operations the manual property can be made atomic by accessing an atomic backing field as demonstrated in \bsref{lst:atomic_property}. Both cases are frequently used in C\#, thus making an \bscode{atomic} version makes the feature usable in a transaction in a orthogonal way.

\begin{lstlisting}[label=lst:auto_atomic_property,
  caption={Automatic Transactional Properties},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Car {
      public atomic int KmDriven { get; set; }
  }
\end{lstlisting}

\begin{lstlisting}[label=lst:atomic_property,
  caption={Manual Transactional Property},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Car {
    private atomic int _kmDriven;
    public int KmDriven {
        get {
            return _kmDriven;
        }
        set {
            _kmDriven = value;
            // Announce value changes
        }
    }
  }
\end{lstlisting}


\subsection{Transactional Local Variables}
The declaration of transactional local variables follows the format:

\bscode{atomic} \bscode{var} $name$ = $expr$;\\
\bscode{atomic} $type$ $var$-$decl$ ( = $expr$ )? ( , $var$-$dcl$ ( = $expr$ )? )+ ;\\

where $var$-$dcl$ is defined as $name$ or $name$ = $expr$. As with transactional fields $type$ can be any existing or user defined type including the \bscode{dynamic} keyword.
\begin{lstlisting}[label=lst:local_variable,
  caption={Local Transactional Variable},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  atomic var s = "abc";
  atomic int i = 12;  
\end{lstlisting}

\section{Transactional Parameters}\label{sec:parameter_design}
In C\# there exist four different kinds of parameters: Value, Reference, Output, and Parameter Array. Their semantics and integration with \stmnamesp will be discussed in the following sections.

\andreas[inline]{We cannot support optional parameters on value types}
\subsection{Transactional Value Parameters}
According to \cite[p. 97]{csharp2013specificaiton}: \textit{``A parameter declared without a ref or out modifier is a value parameter.''} If the parameter is a value type, call-by-value semantics is used, thus assignments to the argument have no effect outside the method scope. If it is a reference type, it is still call-by-value semantics, however side-effects that changes the referenced object, will persist outside the method scope. Due to the call-by-value semantics, assignments to an argument of reference type will have no effect outside the method scope\cite[p. 76]{sestoft2011c}.

In \stmnamesp, a value parameter can be marked as atomic, and becomes a transactional value parameter. Semantically it is equivalent to a transactional local variable which is instantiated to the value of the parameter.\cite[p. 76]{sestoft2011c} 
\andreas{This is true for all cases but for default values. We do not support default values on atomic reference types}
\andreas[inline]{Consider making atomic a parameter modifier, so it cannot be combined with ref, out, or params}
For declaration of transactional parameters the format is as follows:

\bscode{atomic} $param$-$modifier$? $type$ $name$

where $param$-$modifier$ represents C\#'s \bscode{ref} and \bscode{out} keywords, and $type$ can be any existing or user defined type including the \bscode{dynamic} keyword, as previously stated. The \bscode{atomic} keyword cannot be combined with optional parameters\andreas{Hvorfor ikke?}.

\bsref{lst:design_value_parameter} presents an example of an atomic value parameter declaration.

\begin{lstlisting}[label=lst:design_value_parameter,
  caption={Transactional Value Parameter},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  public void Method(atomic int x, atomic string s)
  {
  	//Work with transactional parameters
  }
    
\end{lstlisting}



\subsection{Transactional Reference Parameters}
According to \cite[p. 97]{csharp2013specificaiton}: \textit{``A parameter declared with a ref modifier is a reference parameter.''} As opposed to a value parameter, a reference parameter uses call-by-reference semantics, thus it is the actual reference used as argument, not a copy. Consequently, changes to the argument will have influence outside the method scope, regardless of the parameter being a value or reference type. Changes to the parameter will take effect immediately, both in and outside of the method scope\cite[p. 42]{sestoft2011c}. Additionally, a variable is required to be instantiated before it is passed as a reference parameter\cite[p. 97]{csharp2013specificaiton}.

In \stmnamesp, a reference parameter can be marked as atomic, and becomes a \ac{TRP}. A \ac{TRP} differs from a reference parameter by being tracked in transactions. Assignments to a \ac{TRP} do not take effect outside of the transaction immediately, but when the transaction commits. This is a design choice made to enforce atomicity, as immediate changes to a \ac{TRP} would enable reading intermediate transaction states. A noteworthy detail is, that changes made to a \ac{TRP} through side-effects will be immediate, as we do not track side-effects as discussed in \bsref{sec:tracking}.\lone{Evaluate on design choice}

\bsref{lst:atomic_ref} presents an example of a \bscode{Point} class declaring two \ac{TRP}'s as parameters for the \bscode{ChangeMe} method.

\begin{lstlisting}[label=lst:atomic_ref,
  caption={Transactional Reference Parameter},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Point {
    public atomic int X { get; set; }
    public atomic int Y { get; set; }
    public void ChangeMe(atomic ref int x, atomic ref int y) {
      atomic { 
        x = this.X;
        y = this.Y;
      }
    }    
  }
\end{lstlisting}

\subsection{Transactional Output Parameters}
According to \cite[p. 97]{csharp2013specificaiton}: \textit{``A parameter declared with an out modifier is an output parameter.''} An output parameter behaves as a reference parameter, except that it does not need to be instantiated before being passed as an argument. Additionally, every execution path in the method must assign a value to the variable\cite[p. 42]{sestoft2011c}. 

In \stmname, an output parameter can be marked as atomic, and it becomes a \ac{TOP}. Similar to \ac{TRP}, a \ac{TOP} is tracked in transactions, and assignments in transactions takes effect outside of the transaction when it commits. The reasoning for this, is the same as for \ac{TRP}.

\begin{lstlisting}[label=lst:atomic_out,
  caption={Transactional Output Parameter},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Point {
    public atomic int X { get; set; }
    public atomic int Y { get; set; }
    public void AssignMe(atomic out int x, atomic out int y) {
      atomic { 
        x = this.X;
        y = this.Y;
      }
    }    
  }
\end{lstlisting}

\subsection{Transactional Parameter Array}
According to \cite[p. 17]{csharp2013specificaiton}: \textit{``A parameter array permits a variable number of arguments to be passed to a method''}. Inside the method, the arguments are inside an array of the specified type. This is true, regardless of zero, a single or multiple arguments being passed into to the parameter. As the variable number of arguments is converted to an array, assignments to this array is possible. 

In \stmnamesp, a parameter array can be marked as atomic, making assignments to it trackable in transactions. \bsref{lst:design_param_array} shows an example of such a method declaration.

\begin{lstlisting}[label=lst:design_param_array,
  caption={Transactional Parameter Array},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, params, string, in, foreach}]  % Start your code-block

  public void Method(atomic params string[] strings)
  {
      foreach (var str in strings) { Console.WriteLine(str); }
  }
    
\end{lstlisting}
\section{Example of \stmnamesp}\label{sec:example_design}
\bsref{lst:stm_atomic_syntax}, which is a modified version of the race condition example from our previous study\cite[p. 23]{dpt907e14trending}, presents an example of the syntax extensions \stmnamesp brings to C\#. On line 6 the transactional field \bscode{number} is defined and assigned an initial value of 10. The main method defines and starts two threads. \bscode{t1} checks if the value of \bscode{number} is equal to 10 and assigns \bscode{number} times 3 to the field if the condition is true. These operations are executed as a transaction defined by the \bscode{atomic} keyword and associated block on line 11. \bscode{t2} assigns 20 to \bscode{number} inside a transaction defined on line 17. In this example \stmnamesp removes the race conditions associated with \bscode{t2} changing the value of \bscode{number} between the read on line 12 and the read on line 13. In the case such a change occurs the \ac{STM} system of \stmnamesp will abort and retry one of the implicated transactions in order to resolve the conflict.\lone{impl. detalje, kommer senere? - Referer til impl senere.}
 
\begin{lstlisting}[label=lst:stm_atomic_syntax,
  caption={Transaction Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  using System.Threading;
  
  public class RaceCondition
  {
      public static atomic int number = 10;
  
      public static void Main(string[] args)
      {
          Thread t1 = new Thread ( () => {
              atomic {
                  if (number == 10 )           
                      number = number * 3;
              }
           });
          Thread t2 = new Thread( () => {
              atomic {
                  number = 20;
              }
          });
          t1.Start(); t2.Start();
          t1.Join(); t2.Join();
          int result;
          atomic {
              result = number;          
          }
          Console.WriteLine("Result is: " + result);
      }
  }
\end{lstlisting}

As described in \bsref{subsec:rec_transactions_variables} and \bsref{sec:design_strong_weak_atomicity} \stmnamesp must provide strong atomicity as well as allowing reads and writes to occur from outside atomic blocks. As a result, reads and writes occurring from outside transactions will be accounted for when validating transactions. With that in mind the previous example can be slightly simplified to the example in \bsref{lst:stm_atomic_syntax_simplified}. The atomic block on line 17 of \bsref{lst:stm_atomic_syntax} has been removed. As the atomic block only contains a single write it serves no purpose because the write is still tracked by the \ac{STM} system without need for enclosing it within an atomic block. The atomic block on line 24 of \bsref{lst:stm_atomic_syntax} can also be removed as the read can safely be performed from outside a transactions.

\begin{lstlisting}[label=lst:stm_atomic_syntax_simplified,
  caption={Transaction Syntax Simplified},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  using System.Threading;
  
  public class RaceConditionSimple
  {
      public static atomic int number = 10;
  
      public static void Main(string[] args)
      {
          Thread t1 = new Thread ( () => {
              atomic {
                  if (number == 10)           
                      number = number * 3;
              }
           });
          Thread t2 = new Thread( () => {
                  number = 20;
          });
          t1.Start(); t2.Start();
          t1.Join(); t2.Join();
          Console.WriteLine("Result is: " + number);
      }
  }
\end{lstlisting}
Allowing access to transactional variables from outside transactions dispenses the need for defining a transaction whenever only a single read or write is to be performed. The atomic block then serves the purpose of combining multiple operations to be performed as a single atomic step.

\section{Conditional Synchronization}\label{sec:sync_design}
As described in \bsref{sec:req_conditional} \stmnamesp supports conditional synchronization via the \bscode{retry} and \bscode{orElse} constructs. \stmnamesp extends C\# with a \bscode{retry} statement that can only be used inside atomic blocks. A retry statement takes the format: \bscode{retry}. That is, the keyword is employed as a statement, much like C\#'s \bscode{break} and \bscode{continue} statements\cite[p. 102]{sestoft2011c}. \bsref{lst:stm_atomic_syntax_retry} presents the \bscode{Dequeue} method from a transactional queue. The queue is defined over a singly linked list from which items are dequeued from the front and enqueued in the back. The \bscode{Dequeue} method consists of an atomic block, defined on line 11, performing the dequeue operation as a single atomic step. On line 13 the transaction checks if the queue is empty in which case it executes the retry statement on line 14, blocking the transaction to be retried when the \bscode{\_size} variable changes. If the queue is not empty the head of the queue is removed and the next item in the linked list becomes the new head. Finally the size of the queue is decreased and the value associated with the previous head is returned. 

\begin{lstlisting}[label=lst:stm_atomic_syntax_retry,
  caption={Retry Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  
  public class Queue<T>
  {
  	private atomic Node _head = null;
  	private atomic Node _tail = null;
  	private atomic int _size = 0;

  	public T Dequeue()
  	{
  		atomic{
  		
  			if (_size == 0)
  				retry;

  			var oldHead = _head;

  			_head = _head.Next;
  			if (_head == null)
  				_tail = null;
  			
  			_size--;

  			return oldHead.Value;
  		}
  	}
  	
  	...
  }
\end{lstlisting}

\stmnamesp supports an \bscode{orelse} keyword allowing zero to many \bscode{orElse} blocks to be associated with an atomic block, much like catch clauses are associated with a \bscode{try} statement in many C like languages, including C\#\cite[p. 96]{sestoft2011c}. The  format of the \bscode{atomic} block is therefore extended to:

\bscode{atomic} \{ $S$ \} ( \bscode{orelse} \{ $S$ \} )+

where $S$ is the general class of C\# statements. As an example of the \bscode{orelse} construct  \bsref{lst:stm_atomic_syntax_orelse} depicts a consumer which extracts an item from one of two buffers via the \bscode{ConsumeItem} method. On line 10 the \bscode{ConsumeItem} method defines a transaction. If \bscode{buffer1} is empty the transaction executes the retry statement on line 12, if not an item from \bscode{buffer} is returned. If \bscode{buffer1} is empty and the retry statement is executed, control flows to the \bscode{orelse} block defined on line 15. The \bscode{orelse} then executes its own transaction returning an item from \bscode{buffer2} in case it is not empty. If \bscode{buffer2} is empty the retry statement on line 17 is executed, resulting in the entire atomic block blocking until one of the previously read transactional variables change, at which point the transaction is restarted.

\begin{lstlisting}[label=lst:stm_atomic_syntax_orelse,
  caption={OrElse Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, using}]  % Start your code-block

  using System;
  
  public class Consumer<T>
  {
      private Buffer<T> _buffer1;
      private Buffer<T> _buffer2;

      public T ConsumeItem()
      {
          atomic {
              if(_buffer1.Count == 0)
                  retry;

              return _buffer1.Get();
          } orelse {
              if(_buffer2.Count == 0)
                  retry;

              return _buffer2.Get();
          }
      }
  }
\end{lstlisting}

\section{Nesting}\label{sec:nesting_design}
As described in \bsref{sec:stm_req_nesting} \stmnamesp support nesting of transactions under closed nesting semantics. For this purpose \stmnamesp allows lexical nesting of atomic blocks as shown in \bsref{lst:stm_syntax_lexical_nesting}, where a small program reads two integers from the console. The string arguments are parsed as integers on line 12 to 16. The program then defines two transaction, one starting on line 18 and the other at line 20 which is nested inside the first transaction. The first transaction initiates a nested transaction which sets the transactional variables \bscode{X} and \bscode{Y} based on the input. Due to the semantics with closed nesting these changes only become visible to the outer transaction when the nested transaction commits. As a result the outer transaction uses the updated values when it computes the new value of \bscode{Z} on line 26, but the remaining system can not yet see these updated values. When the outer transaction commits, the assignments to \bscode{X}, \bscode{Y} and \bscode{Z} become visible to the rest of the system as a single atomic step.

\begin{lstlisting}[label=lst:stm_syntax_lexical_nesting,
  caption={Lexical Nesting},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, using}]  % Start your code-block

  public class LexicalNesting
  {
      private atomic static int X = 0;
      private atomic static int Y = 0;
      private atomic static int Z = 0;

      public void Main(string[] args)
      {
          if (args.Length != 2)
              return;

          int tmpx;
          int tmpy;
          if (!int.TryParse(args[0], out tmpx) 
              || !int.TryParse(args[1], out tmpy))
              return;

          atomic
          {
              atomic
              {
                  X = tmpx;
                  Y = tmpy;
              }

              Z = X * Y;
          }
          System.Console.WriteLine(Z);
      }
  }
\end{lstlisting}


To increase the evaluated characteristics\cite[p. 15-21]{dpt907e14trending} of \stmname, specifically writability and orthogonality, dynamic nesting of transactions is allowed. As an example, consider \bsref{lst:stm_nested_transactions_real} where a transaction is defined on line 1. The transaction transfers funds from \bscode{account1} to \bscode{account2} by using the \bscode{withdraw} and \bscode{deposit} methods, which are themselves defined using transactions. Because of the closed nested semantics the transfer is executed as single atomic step.

% Put kilde ind! 

\begin{lstlisting}[label=lst:stm_nested_transactions_real,
  caption={Dynamically nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		var amount = 200;
		account1.withdraw(amount);
		account2.deposit(amount);
	}
       
\end{lstlisting}

\section{Summary of Design}\label{sec:summary_design}
In order to establish an overview, the design requirements for \stmnamesp will be summarized in the following section. A transactional block can be declared by using the \bscode{atomic} statement, to denote a scope for a transaction. Within such a transaction, any assignments to transactional variables, parameters, fields, or properties, will be perceived as executed in one atomic step, by other transactions and non-transactional code. 

To minimize the impact on existing language features, the \bscode{atomic} keyword can be used for making a variable, field, property, or parameter trackable in transactions. This enables continues use of these common C\# features, within a transactional context, including reference parameter, output parameter, and parameter array.

In \stmnamesp we also introduce the keywords \bscode{retry} and \bscode{orelse}, which can be used for conditional synchronization. \bscode{retry} can only be used inside an \bscode{atomic} block, and if encountered, will block execution until a variable in the \bscode{atomic} block has changed. The \bscode{orelse} keyword associates an \bscode{orElse} block, with an \bscode{atomic} block containing a \bscode{retry} statement. The \bscode{orElse} block will change the initial behavior of the \bscode{retry} statement in the \bscode{atomic} block. Instead of blocking execution when encountering a \bscode{retry} statement, the \bscode{orElse} block will be executed. Execution will in that case only block if the bscode{retry} statement of the last \bscode{OrElse} block associated with an \bscode{atomic} block is reached.

Additionally, \stmnamesp allows nesting of transactions, both lexically and dynamically. Nesting uses closed-nesting semantics, thus inner transactions commits into the outer transaction. The inner and outer transactions are not isolated from each other, thus changes made inside the transaction are visible. They are however isolated to all other transactions and non-transactional code.

%Transactional Block
%Transactional Field
%Transactional Properties
%Transactional Local Variables
%Transactional Parameters (value, reference, output, params)
%Conditional Synchronization
%Nesting

%atomic {
%  if ( booleanexpression ) {
%  ...
%}
%
%vs
%
%atomic( booleanexpression) {
%  ...
%}
%
%    atomic {
%      if(_queue.IsEmpty())
%        retry;
%      return _queue.Dequeue();
%    } orElse {
%      if(_queue2.IsEmpty())
%        retry;
%      return _queue2.Dequeue();
%    } orElse {
%      if(_queue3.IsEmpty())
%        retry;
%      return _queue3.Dequeue();
%    }
%    
%vs
%
%    atomic (_queue.IsEmpty()){
%      return _queue.Dequeue();
%    } orElse (_queue2.IsEmpty()){
%      return _queue2.Dequeue();
%    } orElse (_queue3.IsEmpty()){
%      return _queue3.Dequeue();
%    }
%    
%vs
%    atomic {
%      match (_queue.size()) with
%      | 3 -> _queue.dequeue();
%      | 2 -> _queue.peek();
%      | default -> retry;
%      }
         
         
%	atomic keyword for methods and properties
% public atomic void drive (int km) { ... }
% public atomic int wheels { get; set; }



\worksheetend
