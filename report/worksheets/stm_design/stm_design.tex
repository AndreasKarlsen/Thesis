\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{STM Designed for C\#}{0}{Februar 10, 2015}{}{../../}
This chapter describes the process of designing an \ac{STM} system for C\#. \bsref{sec:stm_requirements} highlights the requirements for the \ac{STM} system while \bsref{sec:stm_design} describes the \ac{STM} systems design. Implementation details are described in \bsref{chap:implementation}.
\label{chap:stm_design}
\section{Requirements}
\label{sec:stm_requirements}
\kasper[inline]{General stuff. Atomic block. Language support}
\kasper[inline]{Purpose}
In this section we analyze what properties the design of an \ac{STM} system requires in order to integrate with C\#.
\kasper[inline]{Refer to work last semester}
\andreas[inline]{Should we have an analysis of C\# to see how we should design the STM system?}

\subsection{Strong or Weak Atomicity}
The atomicity guarantee provided by \ac{STM} systems varies, depending on the semantics provided. In \cite{blundell2006subtleties} Blundell et al. defines two levels of atomicity:
%
\begin{defn}\label{def:strong_atomicity}
\emph{[...] strong atomicity to be a semantics in which transactions execute atomically
with respect to both other transactions and non-transactional code.}
\end{defn}
%
\begin{defn}\label{def:weak_atomicity}
\emph{[...] weak atomicity to be a semantics in which transactions are atomic only with respect to other transactions.}
\end{defn}

Strong atomicity provides non-interference and containment between transactional and non-transactional code, where as weak atomicity does not. As an example, using the \bscode{Car} class defined in \bsref{lst:atomicity}, having the \bscode{KmDriven} setter called from one thread, while another thread is calling the \bscode{Drive} method strong and weak atomicity yields different results. Under strong atomicity, everything inside the \bscode{atomic} block at line 12, is not visible to non-transactional code nor is changes made from the setter visible inside the atomic block. The result is, that if the setter is called in the middle of the \bscode{Drive} method, there will be a conflict which must be resolved. 

If only weak atomicity is guaranteed, given the same scenario, the change made through the setter, would be visible inside the atomic block. Thus shared memory between transaction and non-transactional code can lead to race conditions.
%

\begin{lstlisting}[label=lst:atomicity,
  caption={Level of Atomicity},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Car {
    private int _kmDriven;
    public int KmDriven {
      get {
        return _kmDriven;
      }
      set {
        _kmDriven = value;
      }
    }
    public void Drive (int km) {
      atomic {
        _kmDriven += km;
      }
    }
  }
\end{lstlisting}

% TODO: Decide if we want the manual written properties or the auto-implemented ones.
%
%\begin{lstlisting}[label=lst:atomicity,
%  caption={Level of Atomicity},
%  language=Java,  
%  showspaces=false,
%  showtabs=false,
%  breaklines=true,
%  showstringspaces=false,
%  breakatwhitespace=true,
%  commentstyle=\color{greencomments},
%  keywordstyle=\color{bluekeywords},
%  stringstyle=\color{redstrings},
%  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block
%
%  class car {
%    public int KmDriven { get; set; }
%    public void Drive (int km) {
%      atomic {
%        KmDriven += km;
%      }
%    }
%  }
%\end{lstlisting}

\subsection{Conditional Synchronization}
To be a valid alternative for existing C\# synchronization mechanism a \ac{STM} system must be broadly applicable. This requires support for conditional synchronization so that \ac{STM} can be employed in well know scenarios such as shared buffers and other producer consumer setups\cite[p. 128]{tanenbaum2008modern}. \bsref{chap:stm_key_concepts} discusses the \bscode{retry} and \bscode{orElse} constructs proposed in \cite{harris2005composable} for conditional synchronization and composition of alternatives. Supporting such constructs in C\# will increase the applicability of the \ac{STM} system.

Our previous work in \cite{dpt907e14trending} included a implementation of $k$-means clustering algorithm\cite[p. 451]{dataminingconceptsandtechniques} in the functional programming language Clojure. Clojures contains a language integrated \ac{STM} implementation which does not support constructs such as \bscode{retry} and \bscode{orElse}. As a result the implementation requires the use of condition variables and busy waiting in scenarios where the \bscode{retry} construct could have been employed\cite{duffy2010stmnet}.  As such, supplying \bscode{retry} and \bscode{orElse} constructs in C\# will allow for simpler conditional synchronization without the need for busy waiting.

\subsection{Nesting}
The traditional \ac{TL} approach to concurrency has issues with composability due to the threat of deadlocks\cite[p. 58]{sutter2005software} when composing lock based code. \ac{STM} attempts to mitigate this issues by removing the threat of deadlock, and allowing transactions to nest. Nesting can occur both lexically and dynamically\cite[p. 1]{kumar2011hparstm}\cite[p. 42]{harris2010transactional}\cite[p. 2081]{herlihy2011tm}. \bsref{lst:stm_nested_transactions} shows a example a lexically nested transaction while \bsref{lst:stm_nested_transactions_real} shows a example of dynamically nested transactions. Here the withdraw and deposit methods on the accounts are themselves defined using transactions.

\begin{lstlisting}[label=lst:stm_nested_transactions,
  caption={Lexically nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		x = 7;
		atomic{
			y = 12;		
		}
	}
       
\end{lstlisting}

\begin{lstlisting}[label=lst:stm_nested_transactions_real,
  caption={Dynamically nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		var amount = 200;
		account1.withdraw(amount);
		account2.deposit(amount);
	}
       
\end{lstlisting}

An \ac{STM} system for C\# must support nesting of transaction as this will mitigate the before mentioned issues and be a valid alternative to the existing locked based synchronization mechanisms. A more in depth description of the composability problems of the \ac{TL} concurrency model and nesting of transactions can be found in \cite{dpt907e14trending}.


%Flat, open, closed.

\section{Design}
\label{sec:stm_design}
Something with\cite[p. 1]{harris2003language}

%\section{Lock or Obstruction Free}
%\section{Handling Side-effects}
%Immutable collections
%\section{Contention Manager}
%\section{Log or In Place Update}
%\section{Lazy or Eager Update}

\section{Syntax design}

%atomic {
%  if ( booleanexpression ) {
%  ...
%}
%
%vs
%
%atomic( booleanexpression) {
%  ...
%}
%
%    atomic {
%      if(_queue.IsEmpty())
%        retry;
%      return _queue.Dequeue();
%    } orElse {
%      if(_queue2.IsEmpty())
%        retry;
%      return _queue2.Dequeue();
%    } orElse {
%      if(_queue3.IsEmpty())
%        retry;
%      return _queue3.Dequeue();
%    }
%    
%vs
%
%    atomic (_queue.IsEmpty()){
%      return _queue.Dequeue();
%    } orElse (_queue2.IsEmpty()){
%      return _queue2.Dequeue();
%    } orElse (_queue3.IsEmpty()){
%      return _queue3.Dequeue();
%    }
%    
%vs
%    atomic {
%      match (_queue.size()) with
%      | 3 -> _queue.dequeue();
%      | 2 -> _queue.peek();
%      | default -> retry;
%      }
         
         
%	atomic keyword for methods and properties
% public atomic void drive (int km) { ... }
% public atomic int wheels { get; set; }

\worksheetend