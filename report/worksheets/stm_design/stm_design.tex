\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{STM Designed for C\#}{0}{Februar 10, 2015}{}{../../}
This chapter describes the design of \stmname.
A notation similar to Extended Bacus-Naur Form is used for descriptions of the proposed syntax extensions, with ? signaling 0 or 1 and + signaling 0 or more. Parentheses used for grouping as such ( item1, item2 ). Items formatted as \bscode{Non-Term} are non terminals, usually keywords, while terminals are formatted as such, $terminal$. 
\label{chap:stm_design}
\section{Atomic Block \& Transactional variables}
\label{sec:stm_design}
As described in \bsref{subsec:rec_transactions_variables} \stmnamesp must supply language integrated support for defining transaction scopes as well as declaration of transactional variables. For this purpose \stmnamesp extends C\# with the \bscode{atomic} keyword. The \bscode{atomic} keyword will serve as both a statement denoting a transaction scope as well a modifier applicable to the definition of variables. The definition of a transaction takes the format   \bscode{atomic} \{ $S$ \}, where $S$ is the general class of C\# statements. The definition of a transactional field takes the format:

$field$-$modifiers$ $type$ $name$ = $initial$-$value$ ( , $name$ = $initial$-$value$ )+ ; \\
$field$-$modifiers$ $type$ $name$ ( , $name$ )+ ;

where $field$-$modifiers$ includes the new \bscode{atomic} keyword as well as existing C\# modifiers such as \bscode{public}, \bscode{private} and \bscode{static} but not the \bscode{readonly} and \bscode{const} modifiers. The $type$ can be any existing or user-defined type including the \bscode{dynamic} keyword. The calculation of \bscode{initial-value} follows the same rules as standard C\# field initializers\cite[p. 40]{sestoft2011c}. 

The definition of transactional local variables follow the format:

\bscode{atomic}\bscode{var} $name$ = $expr$\\
\bscode{atomic} $type$ $var$-$decl$ ( , $var$-$dcl$ )+ ; 

where $var$-$dcl$ is defined as $name$ or $name$ = $expr$. As with transactional fields $type$ can be any existing or user defined type including the \bscode{dynamic} keyword.

For declaration of transactional parameters the format is as follows:

\bscode{atomic?} $param$-$modifier$? $type$ $name$

where $param$-$modifier$ represents C\#'s \bscode{ref} and \bscode{out} keywords. Just as previously $type$ can be any existing or user defined type including the \bscode{dynamic} keyword. The \bscode{atomic} keyword can not be combined with the C\# \bscode{params} parameter type or optional parameters\cite[p. 42]{sestoft2011c}.

\bsref{lst:stm_atomic_syntax}, which is a modified version of the race condition example from our previous study\cite[p. 23]{dpt907e14trending}, presents an example of the syntax extensions. On line 6 the transactional variable number is defined and assigned an initial value of 10. The main method defines and starts two threads. \bscode{t1} checks if the value of number is equal to 10 and assigns \bscode{number} times 3 to the variable if the condition is true. These operations are executed as a transaction defined by the \bscode{atomic} keyword and associated block on line 11. \bscode{t2} assigns 20 to number inside a transaction defined on line 17. In this example \stmnamesp removes the race conditions associated with \bscode{t2} changing the value of \bscode{number} between the read on line 12 and the read on line 13. In the case such a change occurs the \ac{STM} system of \stmnamesp will abort and retry one of the implicated transactions.
 
\begin{lstlisting}[label=lst:stm_atomic_syntax,
  caption={Transaction Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  using System.Threading;
  
  public class RaceCondition
  {
      public static atomic int number = 10;
  
      public static void Main(string[] args)
      {
          Thread t1 = new Thread ( () => {
              atomic{
                  if (number == 10 )           
                      number = number * 3;
              }
           });
          Thread t2 = new Thread( () => {
              atomic {
                  number = 20;
              }
          });
          t1.Start(); t2.Start();
          t1.Join(); t2.Join();
          int result;
          atomic {
            result = number;          
          }
          Console.WriteLine("Result is: " + result);
      }
  }
\end{lstlisting}

As described in \bsref{subsec:rec_transactions_variables} and \bsref{sec:design_strong_weak_atomicity} \stmnamesp must provide strong atomicity as well as allow reads and writes to occur from outside transactions. As a result, reads and writes occurring from outside transactions will be accounted for when validating transactions. With that in mind the previous example can be slightly simplified to the example in \bsref{lst:stm_atomic_syntax_simplified}. The atomic block on line 17 of \bsref{lst:stm_atomic_syntax} has been removed. As the atomic block only contains a single write it serves no purpose because the write is still tracked by the \ac{STM} system without need for enclosing it within an atomic block. The atomic block on line 24 of \bsref{lst:stm_atomic_syntax} can also be removed as the read can safely be performed from outside a transactions.

\begin{lstlisting}[label=lst:stm_atomic_syntax_simplified,
  caption={Transaction Syntax Simplified},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  using System.Threading;
  
  public class RaceConditionSimple
  {
      public static atomic int number = 10;
  
      public static void Main(string[] args)
      {
          Thread t1 = new Thread ( () => {
              atomic {
                  if (number == 10)           
                      number = number * 3;
              }
           });
          Thread t2 = new Thread( () => {
                  number = 20;
          });
          t1.Start(); t2.Start();
          t1.Join(); t2.Join();
          Console.WriteLine("Result is: " + number);
      }
  }
\end{lstlisting}
Allowing access to transactional variables from outside transactions dispenses the need for defining a transaction whenever only a single read or write is to be performed. The atomic block then serves the purpose of combining multiple operations to be performed as a single atomic step.

\section{Conditional Synchronization}
As described in \bsref{sec:req_conditional} \stmnamesp supports conditional synchronization via the \bscode{retry} and \bscode{orElse} constructs. \stmnamesp extends C\# with a \bscode{retry} statement that can only be used inside atomic blocks. A retry statement takes the format: \bscode{retry}. That is, the keyword is employed as a statement, much like C\#'s \bscode{break} and \bscode{continue} statements\cite[p. 102]{sestoft2011c}. \bsref{lst:stm_atomic_syntax_retry} presents the \bscode{Dequeue} method from a transactional queue. The queue is defined over a singly linked list from which items are dequeued from the front and enqueued in the back. The \bscode{Dequeue} method consists of an atomic block, defined on line 11, performing the dequeue operation as a single atomic step. On line 13 the transaction checks if the queue is empty in which case it executes the retry statement on line 14, blocking the transaction to be retried when the \bscode{\_size} variable changes. If the queue is not empty the new head of the queue is removed and the next item in the linked list becomes the new head. Finally the size of the queue is decreased and the value associated with the previous head is returned. 

\begin{lstlisting}[label=lst:stm_atomic_syntax_retry,
  caption={Retry Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, using}]  % Start your code-block

  using System;
  
  public class Queue<T>
  {
  	private atomic Node _head = null;
  	private atomic Node _tail = null;
  	private atomic int _size = 0;

  	public T Dequeue()
  	{
  		atomic{
  		
  			if (_size == 0)
  				retry;

  			var oldHead = _head;

  			_head = _old.Next;
  			if (_head == null)
  				_tail = null;
  			
  			_size--;

  			return oldHead.Value;
  		}
  	}
  	
  	...
  }
\end{lstlisting}

\stmnamesp supports an \bscode{orelse} keyword allowing zero to many \bscode{orElse} blocks to be associated with an atomic block, much like catch clauses are associated with a \bscode{try} statement in many C like languages, including C\#\cite[p. 96]{sestoft2011c}. The  format of the \bscode{atomic} block is therefor extended to:

\bscode{atomic} \{ $S$ \} ( \bscode{orelse} \{ $S$ \} )+

where $S$ is the general class of C\# statements. As an exampled of the \bscode{orelse} construct  \bsref{lst:stm_atomic_syntax_orelse} depicts a consumer which extracts an item from one of two buffers via the \bscode{ConsumeItem} method. On line 10 the \bscode{ConsumeItem} method defines a transaction. If \bscode{buffer1} is empty the transaction executes the retry statement on line 12, if not an item from \bscode{buffer} is returned. If \bscode{buffer1} is empty and the retry statement is executed, control flows to the \bscode{orelse} block defined on line 15. The \bscode{orelse} then executes its own transaction returning an item from \bscode{buffer2} in case it is not empty. If \bscode{buffer2} is empty the retry statement on line 17 is executed, resulting in the entire atomic block blocking until one of the previously read transactional variables change. At which point the the transaction is restarted.

\begin{lstlisting}[label=lst:stm_atomic_syntax_orelse,
  caption={OrElse Syntax},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, using}]  % Start your code-block

  using System;
  
  public class Consumer<T>
  {
      private Buffer<T> _buffer1;
      private Buffer<T> _buffer2;

      public T ConsumeItem()
      {
          atomic{
              if(_buffer1.Count == 0)
                  retry;

              return _buffer1.Get();
          }orelse{
              if(_buffer2.Count == 0)
                  retry;

              return _buffer2.Get();
          }
      }
  }
\end{lstlisting}

\section{Nesting}
As described in \bsref{sec:stm_req_nesting} \stmnamesp must support nesting of transactions under closed nesting semantics. For this purpose \stmnamesp will allow lexical nesting of atomic blocks as shown in \bsref{lst:stm_syntax_lexical_nesting}. Here a small program reading two integers from the console. The string arguments are parsed as integers on line 12 to 16. The program then defines two transaction, one starting on line 18 the other at line 20 nested inside the first transactions. The first transaction initiates a nested transaction which sets the transactional variables \bscode{X} and \bscode{Y} based on the input. Due to the semantics with closed nesting these changes only become visible to the outer transaction when the nested transaction commits. As a result the outer transaction uses the updated values when it computes the new value of \bscode{Z} on line 26, but the remaining system can not yet see these updates values. When the outer transaction commits the assignments to \bscode{X}, \bscode{Y} and \bscode{Z} becomes visible to the rest of the system as a single atomic step.

\begin{lstlisting}[label=lst:stm_syntax_lexical_nesting,
  caption={Lexical Nesting},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, using}]  % Start your code-block

  public class LexicalNesting
  {
      private atomic static int X = 0;
      private atomic static int Y = 0;
      private atomic static int Z = 0;

      public void Main(string[] args)
      {
          if (args.Length != 2)
              return;

          int tmpx;
          int tmpy;
          if (!int.TryParse(args[0], out tmpx) 
              || !int.TryParse(args[1], out tmpy))
              return;

          atomic
          {
              atomic
              {
                  X = tmpx;
                  Y = tmpy;
              }

              Z = X * Y;
          }
          System.Console.WriteLine(Z);
      }
  }
\end{lstlisting}

To increase the flexibility and orthogonality of the \ac{STM} implementation dynamic nesting of transactions is allowed. As an example consider \bsref{lst:stm_nested_transactions_real} where a transaction is defined on line 1. The transaction transfers funds from \bscode{account1} to \bscode{account2} by using the \bscode{withdraw} and \bscode{deposit} methods, which are themselves defined using transactions. Because of the closed nested semantics the transfer is executed as single atomic step.

\begin{lstlisting}[label=lst:stm_nested_transactions_real,
  caption={Dynamically nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		var amount = 200;
		account1.withdraw(amount);
		account2.deposit(amount);
	}
       
\end{lstlisting}

%atomic {
%  if ( booleanexpression ) {
%  ...
%}
%
%vs
%
%atomic( booleanexpression) {
%  ...
%}
%
%    atomic {
%      if(_queue.IsEmpty())
%        retry;
%      return _queue.Dequeue();
%    } orElse {
%      if(_queue2.IsEmpty())
%        retry;
%      return _queue2.Dequeue();
%    } orElse {
%      if(_queue3.IsEmpty())
%        retry;
%      return _queue3.Dequeue();
%    }
%    
%vs
%
%    atomic (_queue.IsEmpty()){
%      return _queue.Dequeue();
%    } orElse (_queue2.IsEmpty()){
%      return _queue2.Dequeue();
%    } orElse (_queue3.IsEmpty()){
%      return _queue3.Dequeue();
%    }
%    
%vs
%    atomic {
%      match (_queue.size()) with
%      | 3 -> _queue.dequeue();
%      | 2 -> _queue.peek();
%      | default -> retry;
%      }
         
         
%	atomic keyword for methods and properties
% public atomic void drive (int km) { ... }
% public atomic int wheels { get; set; }

\worksheetend
