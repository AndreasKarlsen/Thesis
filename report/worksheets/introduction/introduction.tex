\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Introduction}{0}{Februar 10, 2015}{}{../../}
%
\section{Motivation}
Utilizing tomorrows increasingly faster \acp{CPU} requires changes to the sequential programming paradigm which is popularized in languages such as C, C++, Java, and C\#. As the increase of speed comes in additional cores, and not faster clock speed\cite{sutter2005free}, these changes demands a shift to concurrent programming. Our recent study\cite{dpt907e14trending}, analyzed the runtime performance and characteristics of three different approaches to concurrent programming: \ac{TL}, \ac{STM}, and the Actor model. The study concluded that \ac{STM} eliminates many of the risks related to programming in the context of shared-memory concurrency, notably deadlocks, leading to simpler reasoning and improved usability. Additionally, \ac{STM} fits with the thread model used by sequential languages, and can thereby be applied to existing implementations, without requiring major rewrites. The runtime performance of \ac{STM} is at a competitive level compared to fine-grained locking\cite{dpt907e14trending}. The analysis uncovered one major caveat of \ac{STM}, it is non orthogonal with side-effects, such as \ac{IO} and exceptions\cite{dpt907e14trending}.

Despite of the apparent fit and advantages \ac{STM} could provide to sequential languages\andreas{Should be named something else}\toby{MÃ¥ske noget med mainstream},\ac{STM} has seen no official language integration. Only in Clojure\footnote{\url{http://clojuredocs.org/}} and Haskell\footnote{\url{https://wiki.haskell.org/Haskell}} has \ac{STM} been introduced as a official built-in language feature. \ac{STM} has been introduced as a library based solution in sequential languages, however in order to enable first class support, such as static code analysis and syntax support, language integration is required. With the recent event of open sourcing of the new C\# compiler\footnote{\url{https://github.com/dotnet/roslyn}} and the \ac{CLR}\footnote{\url{https://github.com/dotnet/coreclr}}, Microsoft facilitates an opportunity to extend the C\# language and compiler, and thereby opening up for integrating \ac{STM} into the language.

\section{Related Work}
This section describes related work within the areas of \ac{STM} and the Roslyn compiler. In order learn from the approaches taken by other as well as building a greater understanding of the subjects a number of papers, articles, and other research material of relevance have been read. 

In \cite{harris2005composable} Harris et al. describe their work with integration \ac{STM} into Haskell. Haskell is extend with support for an \bscode{atomic} function with takes a \ac{STM} action as input and produces a \ac{IO} action as output\cite[p. 51]{harris2005composable}. Evaluating the IO action executes the transaction defined by the atomic function. The Haskell setting allowed the authors to divide the world into \ac{STM} actions and \ac{IO} actions\cite[p. 51]{harris2005composable}, effectively disallowing \ac{IO} actions within transactions as well as only allowing \ac{STM} actions to be performed inside memory transactions. The \ac{STM} system is implemented as a C library integrated into the Haskell runtime system. The Haskell constructs utilize this library to execute transactions\cite[p. 56]{harris2005composable}. Furthermore, the authors contribute with a description and implementation of \ac{STM} constructs for conditional synchronization. The \bscode{retry} statement allows a transaction to block until some condition is met at which point the transaction is aborted and retried\cite[p. 52]{harris2005composable}. The \bscode{orElse} can be used to in combination with the retry statement to specify transactional alternatives to be executed in case the previous alternatives encounter a retry\cite[p. 52]{harris2005composable}.

\kasper[inline]{May reference last project for more detailed explanation of constructs.}

\cite{herlihy2003software} describes the DSTM system developed by Herlihy et al. DSTM is a library based \ac{STM} system aimed at the C++ and Java programming languages\cite{herlihy2003software}[p. 92]. DSTM uses transactional objects which encapsulate regular objects and provide \ac{STM} based access and synchronization\cite{herlihy2003software}[p. 9]. Each transactional object contains a record of its current value, old value and a reference to the transaction which created the record\cite{herlihy2003software}[p. 95]. Compare and swap is employed to atomically update the state of a transactional object\cite{herlihy2003software}[p. 96]. DSTM is a obstruction-free\cite{herlihy2003obstruction} \ac{STM} system. Obstruction freedom guarantees that any thread which runs for long enough without encountering a synchronization conflict makes progress\cite{herlihy2003obstruction}[p. 1]. Unlike stronger progress guarantees such as lock-freedom and wait-freedom obstruction freedom does not prevent livelock. As a result DSTM employees a contention manager to ensure progress in practice\cite{herlihy2003software}[p. 93]. A extended version of DSTM called DSTM2 is presented in \cite{herlihy2006flexible}. Here the authors focused on creating a simple and flexible API for the \ac{STM} library.

In \cite{harris2003language} the authors describe how they integrated \ac{STM} into the Java programming language by modifying both the compiler\cite[p. 4]{harris2003language} and virtual machine\cite[p. 9]{harris2003language}. The authors design, implement and Performance test a obstruction free \ac{STM} system. The \ac{STM} system uses per object ownership records to track the objects the objects version number as well as which transaction currently owns the object\cite[p. 6]{harris2003language}. Transaction descriptors are employed in order to keep track of the read and write operations performed by a transaction.
Transaction are committed  using \ac{CAS} in order to ensure atomicity\cite[p. 7]{harris2003language}.

\cite{dice2006transactional} describes the TL2 \ac{STM} system designed at Sun Microsystems Laboratories by Dice et al. While many of the other \ac{STM} systems described here adopt a obstruction-free approach to \ac{STM} implementation, TL2 uses commit time logging\cite{dice2006transactional}[p. 199]. A transaction explicitly records its read and write operations in a associated read and write set\cite{dice2006transactional}[p. 198]. Instead of writing directly to memory all writes are written to the write set. When at transaction is about to commit it acquires the lock on each object in the write set and writes the values contained in the write set to the actual memory locations before releasing the locks\cite{dice2006transactional}[p. 200].
A global version clock is used to verify that transactions executed in isolation\cite{dice2006transactional}[p. 201]. As a transaction starts it reads the current value of the global version clock, storing it locally so it can be used for validation. As a transaction is about to commit it validates its read set by for every object in the read set comparing the locally stored read stamp with the objects associated write stamps\cite{dice2006transactional}[p. 200]. If any writes stamps are higher than the locally stored read stamp a conflict has occurred and the transaction must abort and restart.  
\worksheetend