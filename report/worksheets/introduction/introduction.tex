\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Introduction}{0}{Februar 10, 2015}{}{../../}
%
\section{Motivation}
Utilizing tomorrows increasingly faster \acp{CPU} requires changes to the sequential programming paradigm which is popularized in languages such as C, C++, Java, and C\#. As the increase of speed comes in additional cores, and not faster clock speed\cite{sutter2005free}, these changes demands a shift to concurrent programming. Our recent study\cite{dpt907e14trending}, analyzed the runtime performance and characteristics of three different approaches to concurrent programming: \ac{TL}, \ac{STM}, and the Actor model. The study concluded that \ac{STM} eliminates many of the risks related to programming in the context of shared-memory concurrency, notably deadlocks, leading to simpler reasoning and improved usability. Additionally, \ac{STM} fits with the thread model used by sequential languages, and can thereby be applied to existing implementations, without requiring major rewrites. The runtime performance of \ac{STM} is at a competitive level compared to fine-grained locking\cite{dpt907e14trending}. The analysis uncovered one major caveat of \ac{STM}, it is non orthogonal with side-effects, such as \ac{IO} and exceptions\cite{dpt907e14trending}.

Despite of the apparent fit and advantages \ac{STM} could provide to sequential languages\andreas{Should be named something else}\toby{Måske noget med mainstream},\ac{STM} has seen no official language integration. Only in Clojure\footnote{\url{http://clojuredocs.org/}} and Haskell\footnote{\url{https://wiki.haskell.org/Haskell}} has \ac{STM} been introduced as a official built-in language feature. \ac{STM} has been introduced as a library based solution in sequential languages, however in order to enable first class support, such as static code analysis and syntax support, language integration is required. With the recent event of open sourcing of the new C\# compiler\cite{roslyn}  and the \ac{CLR}\cite{coreclr}, Microsoft facilitates an opportunity to extend the C\# language and compiler, and thereby opening up for integrating \ac{STM} into the language.
%\footnote{\url{https://github.com/dotnet/roslyn}}
%\footnote{\url{https://github.com/dotnet/coreclr}}
\andreas{Programmer might not want to switch to an entire different language, in order to gain a single feature. Due to this, it makes sense to bring the feature to the language.}
\section{Related Work}
This section describes related work within the areas of \ac{STM}. In order learn from the approaches taken by other as well as building a greater understanding of the subject a number of papers, articles, and other research material of relevance have been read. This sections describes a selection of the most relevant literature on the subject.

\subsection{Composable Memory Transactions}
In \cite{harris2005composable} Harris et al. describe their work with integrating \ac{STM} into Haskell. Haskell is extended with support for an \bscode{atomic} function which takes an \ac{STM} action as input and produces an \ac{IO} action as output\cite[p. 51]{harris2005composable}. Evaluating the IO action executes the transaction defined by the atomic function. The Haskell setting allowed the authors to divide the world into \ac{STM} actions and \ac{IO} actions\cite[p. 51]{harris2005composable}, effectively disallowing \ac{IO} actions within transactions as well as only allowing \ac{STM} actions to be performed inside memory transactions. The \ac{STM} system is implemented as a C library integrated into the Haskell runtime system. The Haskell constructs utilize this library to execute transactions\cite[p. 56]{harris2005composable}. Furthermore, the authors contribute with a description and implementation of \ac{STM} constructs for conditional synchronization. The \bscode{retry} statement allows a transaction to block until some condition is met at which point the transaction is aborted and retried\cite[p. 52]{harris2005composable}. The \bscode{orElse} can be used in combination with the retry statement to specify transactional alternatives to be executed in case the previous alternatives encounter a retry\cite[p. 52]{harris2005composable}.

\kasper[inline]{May reference last project for more detailed explanation of constructs.}
\subsection{\ac{STM} for Dynamic-sized Data Structures}
\cite{herlihy2003software} describes the DSTM system developed by Herlihy et al. DSTM is a library based \ac{STM} system aimed at the C++ and Java programming languages\cite{herlihy2003software}[p. 92]. DSTM uses transactional objects which encapsulate regular objects and provide \ac{STM} based access and synchronization\cite{herlihy2003software}[p. 9]. Each transactional object contains a record of its current value, old value and a reference to the transaction which created the record\cite{herlihy2003software}[p. 95]. Compare and swap is employed to atomically update the state of a transactional object\cite{herlihy2003software}[p. 96]. DSTM is an obstruction-free\cite{herlihy2003obstruction} \ac{STM} system. Obstruction freedom guarantees that any thread which runs for long enough without encountering a synchronization conflict makes progress\cite{herlihy2003obstruction}[p. 1]. Unlike stronger progress guarantees such as lock-freedom and wait-freedom, obstruction freedom does not prevent livelock\cite[p. 47]{harris2010transactional}. As a result DSTM employees a contention manager to ensure progress in practice\cite{herlihy2003software}[p. 93]. An extended version of DSTM called DSTM2 is presented in \cite{herlihy2006flexible}. Here the authors focused on creating a simple and flexible \acsu{API} for the \ac{STM} library.\andreas{Does the DSTM2 contributes with any info we can use? I propose a deletion!}

\subsection{Language Support for Lightweight Transactions}
In \cite{harris2003language} the authors describe how they integrated \ac{STM} into the Java programming language by modifying both the compiler\cite[p. 4]{harris2003language} and virtual machine\cite[p. 9]{harris2003language}. The authors design, implement and performance test an obstruction free \ac{STM} system. The \ac{STM} system uses a non-blocking implementation, and thus guarantees the absence of deadlocks and priority inversion. Additionally, non-conflicting executions are executed concurrently. It uses per object ownership records to track the objects version number as well as which transaction currently owns the object\cite[p. 6]{harris2003language}. Transaction descriptors are employed in order to keep track of the read and write operations performed by a transaction. Transactions are committed  using \ac{CAS} in order to ensure atomicity\cite[p. 7]{harris2003language}. The performance tests show how the \ac{STM} system scales almost as well or better than locks, when the amount of cores available are increased\cite[p. 12]{harris2003language}. The test cases was performed on small examples, e.g. a ConcurrentHashmap.

\subsection{Transactional Locking \rom{2}}
\cite{dice2006transactional} describes the TL2 \ac{STM} system designed at Sun Microsystems Laboratories by Dice et al. While many of the other \ac{STM} systems described here adopt an obstruction-free approach to implementing \ac{STM}, TL2 uses commit time logging\cite[p. 199]{dice2006transactional}. A transaction explicitly records its read and write operations in an associated read and write set\cite[p. 198]{dice2006transactional}. Instead of writing directly to memory, all writes are written to the write set. When a transaction is about to commit it acquires the lock on each object in the write set and writes the values contained in the write set to the actual memory locations before releasing the locks\cite[p. 200]{dice2006transactional}. This corresponds to a two phase locking scheme\cite[p. 455]{tanenbaum2008modern}. A global version clock is used to verify that transactions are executed in isolation\cite[p. 201]{dice2006transactional}. As a transaction starts it reads the current value of the global version clock, storing it locally so it can be used for validation. As a transaction is about to commit it validates its read set by, for every object in the read set, comparing the locally stored read stamp with the objects associated write stamps\cite[p. 200]{dice2006transactional}. If any write stamps are higher than the locally stored read stamp, a conflict has occurred and the transaction must abort and restart. 

\subsection{A (Brief) Retrospective on Transactional Memory}
Inside Microsoft, a group of architects and researchers led an incubation project. Joe Duffy, now director of the Compiler and Language Platform group at Microsoft gives a retrospective view on their work in \cite{duffy2010stmnet}. Their goal was to provide a first class \ac{STM} implementation, i.e. integrated in the language, supported by \ac{JIT}, \ac{GC}, compiler and debugger. Their overall strategy was to use a version number for optimistic reads, and a lock for writes. Initially they chose weak atomicity and update in-place, but realized that this approach suffered from privatization issues\toby{fortæller vi et sted hvad det er?}, breaking the isolation. They settled on a write on-commit approach, but suffered from false sharing\toby{hvad er false sharing?} between transactional and non-transactional code, due to loss of granularity which was reduced to object level. They chose unbounded transactions, to provide a broader appeal. They would rely on compiler optimization through static analysis to remove unnecessary barriers as well as finding violations of the isolation introduced by the programmer. They identified \ac{STM} as a systemic and platform wide technology shift, just like generics. Having a platform wide change, requires careful integration with existing language features, in order to preserve the orthogonality. They identified several critical operations, that would cause trouble if permitted inside a transaction since their actions are non-reversible per default, e.g. allocation of finalize objects, \ac{IO} calls, GUI operations, P/Invokes to Win32, library calls and use of locks. This ultimately led to the realization that not all problems are transactional, and very little .NET code could actually run inside the transaction, but computations performed solely in memory. This combined with the privatization issue and several minor but continuous arising problems, caused Joe Duffy to state, that the research area of \ac{STM} was not mature enough yet, and thus STM.NET never made it outside of the incubation project.

\kasper[inline]{Existing STM support in C\#} 

\section{Scope}
%\andreas[inline]{We are not solving the side-effect problem}
%\andreas[inline]{Bringing the concurrency construct STM into a C\#}
%\kasper[inline]{No coreclr}
%\kasper[inline]{Focus on the C\# part of Roslyn}
\kasper[inline]{Maybe move this section to after the problem statement}
\ac{STM} has been an active area of research for almost 20 years\cite{shavit1997software}. While the research has come far from the initial proposal of statically sized memory transactions, the area still has unsolved problems. Including issues with side effect, \ac{IO} and exceptions occurring inside transactions\cite{harris2005exceptions}. While more research in these areas would be of interest to the community, it is not the focus of this master thesis. As such we restrict the project to investigating integration of \ac{STM} in the C\# programming language and not on solving these known issues. Furthermore while the creation of new \ac{STM} algorithms with good performance is of interest to the research community this is not the focus of this thesis. Instead  the focus is on the integration of \ac{STM} in the C\# programming language.

The Roslyn project contains compilers for both Visual Basic and the C\# programming languages\cite{roslyn}. As this master thesis focuses on C\# we will restrict any investigation into the Roslyn compiler to focus on the C\# compiler as well as shared functionality of interest. 

Microsoft recently released the source code for an independent version of its .NET runtime environment \acl{CLR}, called \ac{CLR} Core on Github\cite{coreclr}. While this undoubtedly present many exiting research opportunities for the area of \ac{STM} as well as other computer science areas, we consider the \ac{CLR} to be out of scope for this thesis. With the limited time frame available for the project, investigating, understanding and modifying the \ac{CLR} will not be feasible on top of the existing workload. 

\section{Problem Statement}
The goals of this master thesis is to investigate the possibility of supplying language integrated support for \ac{STM} in the C\# programming language. In order to structure our investigation we have extracted a number of problem statement questions. The questions are based on findings from the theory investigated in our previous study, investigation of related work, exploratory investigations into \ac{STM} implementations, and the Roslyn compiler. These questions will serve as a guideline for integrating \ac{STM} into the C\# language, as well as being used to conclude upon the project in \bsref{chap:conclusion}.

\begin{enumerate}
\item How is the Roslyn compiler structured?
\item What features should an \ac{STM} system for C\# contain?
\item What problems exist in integrating \ac{STM} in C\#?
\item How can the Roslyn compiler be utilized to integrate \ac{STM} into the C\# language?
\item What different implementation strategies exist for \ac{STM}?
\end{enumerate}

Answering these questions along with supplying a prototype implementation will build the foundation for evaluating how \ac{STM} fits into the C\# programming language and what benefits it brings.
 
\section{Preliminary Risk Mitigation}
In order to mitigate the risks associated with the areas of implementing an \ac{STM} system and the Roslyn compiler, a preliminary risk mitigation was conduced. As these areas are new to us, they initially present some uncertainty in the project. A risk mitigation will further our understanding. As our understanding grows the uncertainty will be reduced.

To mitigate the risks associated with developing an \ac{STM} system, a number of papers describing \ac{STM} system implementations were investigated. This gave us a better understanding of the known approaches for implementing \ac{STM} systems. To get some hands on experience, a prototype \ac{STM} system based on the two implementations described in \cite{herlihy2012art}[p. 424] was developed\andreas{Should we include those on the CD?}. Developing such a prototype system furthered our understanding of the different implementations strategies as well as gave us some hands on experience.

As the Roslyn compiler has only recently been released, the amount of available literature on the subject is limited, consisting of mostly: a white paper\cite{ng2012roslyn}, documentation associated with the Roslyn Github repository\cite{roslynwiki}, sample implementations and walkthroughs\cite{roslynsamples}, as well as blog posts. Most of these sources describe the compiler \ac{API} opposed to the structure of the compiler. In order to further our understanding of the Roslyn compiler we have investigated these sources. In addition, an exploratory modification of the compiler, investigating its structure was done. The lexer and parser of the compiler was modified to handle the syntax of an \bscode{atomic} block. The exploratory implementation furthered our knowledge of the compilers structure and \ac{API} design, as well as ensured the feasibility of compiler modifications.

\andreas[inline]{How did we tackle Roslyn?}
\andreas[inline]{How did we tackle the insecurity in STM? (Known not solved problem areas)}

\worksheetend