\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Introduction}{0}{Februar 10, 2015}{}{../../}
%
This chapter describes the motivation behind this project in \bsref{sec:motivation}. Related work is presented in \bsref{sec:intro_related_work} and the scope of the project is addressed in \bsref{sec:scope}. The hypothesis and problem statement questions are presented in \bsref{sec:problem_statement}. Finally, the project evaluation method is stated in \bsref{sec:eval_approach}.

\label{chap:introduction}
\section{Motivation}\label{sec:motivation}
Today the increase in \acsu{CPU} speed comes in the form of additional cores, as opposed to faster clock speed\cite{sutter2005free}. In order to utilize this increase in speed, many of the popular sequential programming languages, such as C, C++, Java, and C\#, require changes or new additions in order to adapt\cite[p. 56]{sutter2005software}. Our recent study\cite{dpt907e14trending}, analyzed the runtime performance and characteristics of three different approaches to concurrent programming: \ac{TL}, \ac{STM}, and the Actor model. The study concluded that \ac{STM} eliminates many of the risks related to programming in the context of shared-memory concurrency, notably deadlocks, leading to simpler reasoning and improved usability. Additionally, \ac{STM} fits with the thread model used by sequential languages, and can thereby be applied to existing implementations, without requiring major rewrites. The runtime performance of \ac{STM} is at a competitive level comparable to that of fine-grained locking\cite{dpt907e14trending}. The analysis uncovered one major caveat of \ac{STM}, it is not orthogonal with side-effects, such as \ac{IO} and exceptions\cite{dpt907e14trending}.
%Utilizing tomorrows increasingly faster \acp{CPU} requires changes to the sequential programming paradigm\cite[p. 56]{sutter2005software} which is popularized in languages such as C, C++, Java, and C\#.

\ac{STM} has, as of the time of writing, seen only limited official language integration, despite of the advantages \ac{STM} could provide to sequential languages.To our knowledge   \ac{STM} has only been introduced as an official built-in language feature in Clojure\footnote{\url{http://clojuredocs.org/}} and Haskell\footnote{\url{https://wiki.haskell.org/Haskell}}. \ac{STM} has been introduced as a library based solution in sequential languages. However to supply features such as static analysis and syntax support require language integration.  From the programmers point of view, a single feature rarely justifies adopting a new programming language. Especially considering that adopting a new language may require rewriting existing code. Thus integrating \ac{STM} into existing languages will benefit the programmers of these languages.

As of April 2014  and February 2015 Microsoft open sourced the new C\# compiler\cite{roslyn} codenamed Roslyn and the Core \ac{CLR} \cite{coreclr} respectively. Microsoft thereby facilitates an opportunity to extend the C\# language and compiler as well as its runtime system, thereby opening up for integrating \ac{STM} into the language.
%\footnote{\url{https://github.com/dotnet/roslyn}}
%\footnote{\url{https://github.com/dotnet/coreclr}}
\section{Related Work}
\label{sec:intro_related_work}
This section describes related work within the area of \ac{STM}. In order to learn from the approaches taken by others as well as achieving a better understanding of the subject, a number of papers, articles, and other research material of relevance has been read. The focus of this section has been on identifying different strategies for language integration of \ac{STM} as well as different \ac{STM} implementation strategies.

\subsection{Composable Memory Transactions}
In \cite{harris2005composable} Harris et al. describe their work with integrating \ac{STM} into Haskell. Haskell is extended with support for an \bscode{atomic} function which takes an \ac{STM} action as input and produces an \ac{IO} action as output\cite[p. 51]{harris2005composable}. Evaluating the IO action executes the transaction defined by the atomic function. The Haskell setting allows the authors to divide the world into \ac{STM} actions and \ac{IO} actions\cite[p. 51]{harris2005composable}, effectively disallowing \ac{IO} actions within transactions as well as only allowing \ac{STM} actions to be performed inside transactions. The \ac{STM} system is implemented as a C library integrated into the Haskell runtime system. The Haskell constructs utilize this library to execute transactions\cite[p. 56]{harris2005composable}. Furthermore, the authors provide a description and implementation of \ac{STM} constructs for conditional synchronization. The \bscode{retry} statement allows a transaction to block until some condition is met at which point the transaction is aborted and re-executed\cite[p. 52]{harris2005composable}. The \bscode{orElse} can be used in combination with the retry statement to specify transactional alternatives to be executed in case the previous alternatives encounter a retry\cite[p. 52]{harris2005composable}.

\subsection{\ac{STM} for Dynamic-sized Data Structures}
In \cite{herlihy2003software}, Herlihy et al. describe the \ac{DSTM} system. \ac{DSTM} is a library based \ac{STM} system aimed at the C++ and Java programming languages\cite{herlihy2003software}[p. 92]. \ac{DSTM} uses transactional objects which encapsulate regular objects and provide \ac{STM} based access and synchronization\cite{herlihy2003software}[p. 9]. Each transactional object contains a record of its current value, old value and a reference to the transaction which created the record\cite{herlihy2003software}[p. 95]. A \ac{CAS} operation is employed to atomically update the state of a transactional object\cite{herlihy2003software}[p. 96]. \ac{DSTM} is an obstruction-free\cite{herlihy2003obstruction} \ac{STM} system. Obstruction-freedom guarantees that any thread which runs long enough without encountering a synchronization conflict makes progress\cite{herlihy2003obstruction}[p. 1]. Unlike stronger progress guarantees such as lock-freedom and wait-freedom, obstruction-freedom does not prevent livelock\cite[p. 47]{harris2010transactional}. As a result \ac{DSTM} employs a contention manager to ensure progress in practice\cite{herlihy2003software}[p. 93]. An extended version of \ac{DSTM} called DSTM2 is presented in \cite{herlihy2006flexible}. Here the authors focuses on creating a simple and flexible \acsu{API} for the \ac{STM} library.

\subsection{Language Support for Lightweight Transactions}
In \cite{harris2003language} the authors describe how they integrated \ac{STM} into the Java programming language by modifying both the compiler\cite[p. 4]{harris2003language} and virtual machine\cite[p. 9]{harris2003language}. The authors design, implement and performance test an obstruction free \ac{STM} system. The \ac{STM} system uses a non-blocking implementation, and thus guarantees the absence of deadlocks and priority inversion. Additionally, non-conflicting executions are executed concurrently. Per object, it uses an ownership record to track the object's version number as well as which transaction currently owns the object\cite[p. 6]{harris2003language}. Transaction descriptors are employed in order to keep track of the read and write operations performed by a transaction. Transactions are committed  using \ac{CAS} in order to ensure atomicity\cite[p. 7]{harris2003language}. The performance tests show how the \ac{STM} system scales almost as well or better than locking, when the amount of cores available is increased\cite[p. 12]{harris2003language}. The test cases were performed on data structures, e.g. a ConcurrentHashmap, as opposed to an entire system.

\subsection{Transactional Locking \rom{2}}
In \cite{dice2006transactional} the TL\rom{2} \ac{STM} system designed at Sun Microsystems Laboratories by Dice et al. is described. While many of the other \ac{STM} systems described here adopt an obstruction-free approach to implementing \ac{STM}, TL\rom{2} uses commit time locking\cite[p. 199]{dice2006transactional}. A transaction explicitly records its read and write operations in a read and write set\cite[p. 198]{dice2006transactional}. Instead of writing directly to memory, all writes are written to the write set. When a transaction is about to commit it acquires the lock on each object in the write set and writes the values contained in the write set to the actual memory locations before releasing the locks\cite[p. 200]{dice2006transactional}. This corresponds to a two phase locking scheme\cite[p. 455]{tanenbaum2008modern}. A global version clock is used to verify that transactions are executed in isolation\cite[p. 201]{dice2006transactional}. As a transaction starts it reads the current value of the global version clock, storing it locally so it can be used for validation. As a transaction is about to commit, it validates its read set by comparing the locally stored read stamp with each object's associated write stamp\cite[p. 200]{dice2006transactional}. If any write stamps are higher than the locally stored read stamp, a conflict has occurred and the transaction must abort and re-execute.

\subsection{A (Brief) Retrospective on Transactional Memory}
Inside Microsoft, a group of architects and researchers led an incubation project. Joe Duffy, now director of the Compiler and Language Platform group at Microsoft, gives a retrospective view on their work in \cite{duffy2010stmnet}. Their goal was to provide a language integrated \ac{STM} system with support in the \ac{JIT} compiler, garbage collector, compiler and debugger. Their overall strategy was to use a version number for optimistic reads, and a lock for writes. Initially they chose weak atomicity and update in-place, but realized that this approach suffered from privatization issues, breaking the isolation. They settled on a write on-commit approach and chose unbounded transactions to provide a broader appeal. Furthermore they relied on compiler optimization through static analysis to remove unnecessary barriers as well as finding violations of the isolation introduced by the programmer. The authors identified \ac{STM} as a systemic and platform wide technology shift, just like generics. Having a platform wide change, requires careful integration with existing language features, in order to preserve the orthogonality. Several critical operations, that would cause trouble if permitted inside a transaction since their actions are non-reversible, were identified. These include allocation of finalize objects, \ac{IO} calls, GUI operations, P/Invokes to Win32, library calls and the use of locks. Ultimately, this led to the realization that not all problems are transactional. Very little .NET code, but computations performed solely in memory, could actually run inside transactions. This combined with the privatization issue and several minor but continuous arising problems, caused Joe Duffy to state that the research area of \ac{STM} was, as of January 2010, not mature enough, and thus STM.NET never made it outside of the incubation project.

\section{Scope}\label{sec:scope}
%\andreas[inline]{We are not solving the side-effect problem}
%\andreas[inline]{Bringing the concurrency construct STM into a C\#}
%\kasper[inline]{No coreclr}
%\kasper[inline]{Focus on the C\# part of Roslyn}
\ac{STM} has been an active area of research for almost 20 years\cite{shavit1997software}. While the research has come far from the initial proposal of statically sized memory transactions, the area still has unsolved problems, including issues with side effects, \ac{IO}, and exceptions occurring inside transactions\cite{harris2005exceptions}. While more research into solving these known problems as well as the creation of new \ac{STM} algorithms with good performance is of interest to the research community, it is not the focus of this master thesis. Instead the focus is evaluating the integration of \ac{STM} in the C\# programming language. Specifically C\# 5.0, the most recent version at the time of writing\cite{csharp2013specificaiton}.

%As such we restrict the project to investigating integration of \ac{STM} in the C\# programming language and not on solving these known issues.

The Roslyn compiler project contains compilers for both Visual Basic and C\#\cite{roslyn}. As this master thesis focuses on C\# we will restrict any investigation into the Roslyn compiler to focus on the C\# compiler as well as shared functionality of interest. We realize that the Roslyn compiler contains features for the unreleased C\# 6.0, but as these features are uncompleted and not final, they will not be accounted for in the integration.

As of February 2015 Microsoft released the source code for an independent version of its .NET runtime environment \acl{CLR}, called the Core \ac{CLR} on Github\cite{coreclr}. While this undoubtedly presents many research opportunities for the area of \ac{STM} as well as other computer science areas, the \ac{CLR} is considered out of scope for this thesis. The \ac{CLR} Core is mainly written in C++\cite{coreclr}, a language with which we have only limited experience. Furthermore, the Core \ac{CLR} consists of roughly 2.6 million lines of code\cite{coreclrBlog} making it a complex and time demanding task to gain an understanding of its structure.

\section{Problem Statement}\label{sec:problem_statement}
The goal of this master thesis is to investigate the usability of language integrated support for \ac{STM} in C\#, compared to a library based solution and existing locking features. To formalize our goal, we have constructed the following hypothesis:

\paragraph{Hypothesis} Language integrated \ac{STM} provides a valid alternative to locking in terms of usability, and provides additional benefits compared to library based \ac{STM}, when solving concurrency problems in C\#.

In order to evaluate the hypothesis, a language integrated \ac{STM} system for C\#, called \stmname, and \ac{STM} library for the .NET platform, will be designed and implemented. Using \stmname and the \ac{STM} library a number of representative concurrent problems will be implemented. These implementations will be compared to equivalent lock based implementations using the evaluation method defined in \bsref{sec:eval_approach}.

\subsection{Problem Statement Questions}
In order to structure our investigation we have identified a number of problem statement questions. The questions are based on findings from the theory investigated in our previous study\cite{dpt907e14trending}, investigation of related work, exploratory investigations into \ac{STM} implementations, and the Roslyn compiler.

\begin{enumerate}
\item What features should an \ac{STM} system for C\# contain?
\item What problems exist in integrating \ac{STM} in C\#?
\item What different implementation strategies exist for \ac{STM}?
\item How is the Roslyn compiler structured?
\item How can the Roslyn compiler be utilized to integrate \ac{STM} into the C\# language?
\item How does the characteristics differ when using locking, library-based \ac{STM} and language-based \ac{STM} in the context of C\#.
\end{enumerate}

\section{Evaluation Method}\label{sec:eval_approach}
The evaluation is conducted by analyzing  characteristics of the different concurrency approaches in a qualitative manner, based on a number of concurrent implementations. The  characteristics utilized are an extended version of the characteristics employed in our prior study\cite[p. 15-21]{dpt907e14trending}.  Each of the characteristics highlight key differences in the usability of the concurrency approaches. Combined, they form a comprehensive, although not exhaustive, view of the usability of the concurrency approaches. By evaluating both library-based \ac{STM} and language based \ac{STM} their differences will be highlighted which can serve to justify language integration of \ac{STM}.

\subsection{Selected Problems}\label{sec:eval_selected_problems}
Four concurrency problems have been selected for evaluation:
\begin{enumerate}
\item The Dining Philosophers (\bsbilagref{app:dining_phil})
\item The Santa Claus Problem (\bsbilagref{app:santa})
\item A Concurrent Queue (\bsbilagref{app:queue})
\item A Concurrent Hashmap (\bsbilagref{app:hashmap})
\end{enumerate}
The Dining Philosophers problem represents a well known concurrency problem which highlights some of the pitfalls associated with synchronization of threads. The Santa Claus problem encompasses a high degree of modeling and requires complex synchronization, e.g. allowing only a predefined number of threads to enter a critical region at a time and waiting on one of multiple conditions. Employing this problem helps investigate what advantages \ac{STM} provides compared to locking in such scenarios. Both the concurrent queue and hashmap represent real world problems. Concurrent queues are widely used in concurrent applications\cite{michael1996simple} and concurrent hashmaps can for example be used in a compiler to maintain a symbol table\cite{cormen2009introduction}. Both data structures also benefit from fine grained synchronization and is available in a number of languages, including C\#. Together these problems provide a varied perspective by exerting different aspects of each approach e.g. waiting on one of multiple conditions and fine grained synchronization.

The source code for each of the implementations can be found in \bsbilagref{app:eval_implementations}, together with a description of the chosen strategy. Common for all the solutions are, that they must solve the problem by using the specified concurrency approach and utilize the strengths of the approach.

\subsection{Evaluation of Characteristics}\label{sec:eval_chars}
For each of the selected problems an implementation will be created using locking, library based \ac{STM} and \stmname. Based on these implementations each concurrency approach will be evaluated according to an extended version of the characteristics defined in our previous work\cite[p. 15-21]{dpt907e14trending}. These characteristics are a combination of general characteristics for concurrency models such as pessimistic or optimistic concurrency, as well as characteristics such as simplicity and readability which have been used to evaluate the usability of programming languages\cite[p. 7]{sebestaProLang}. The additional characteristics are Data Types and Syntax Design, which are relevant as the characteristics are now used to evaluate concrete implementations in a language as opposed to concurrency models in our previous work\cite{dpt907e14trending}.

Each of these characteristics range from one extreme to another, e.g. high or low readability, however a concurrency approach may not reside at one of these extremes. Therefore each concurrency approach will be given a placement on the spectrum of each characteristic, based on the findings of the evaluation. In order to visualize this placement a scale similar to the one presented in \bsref{fig:evel_example} is employed. Here \bscode{X} and \bscode{Y} represent the two extremes of the spectrum while the indicators represent the placement of each of the concurrency approaches on the spectrum. As an example \bscode{X} and \bscode{Y} could be low and high writability, \bsref{fig:evel_example} then shows that each of the concurrency approaches resides more towards the high writability end of the spectrum.
\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/evaluation/figures/eval_example}
\caption{Example of characteristic evaluation scale}\label{fig:evel_example}
\end{figure}
As the evaluation of the characteristics is subjective, the placement of each concurrency approach on a spectrum allows for a more clear comparison of the findings in the evaluation.
\worksheetend