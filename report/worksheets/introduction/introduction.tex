\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Introduction}{0}{Februar 10, 2015}{}{../../}
%
\section{Motivation}
Utilizing tomorrows increasingly faster \acp{CPU} requires changes to the sequential programming paradigm which is popularized in languages such as C, C++, Java, and C\#. As the increase of speed comes in additional cores, and not faster clock speed\cite{sutter2005free}, these changes demands a shift to concurrent programming. In \cite{dpt907e14trending}, a recent study made by us, analyzed the runtime performance and characteristics of in three different approaches to concurrent programming: \ac{TL}, \ac{STM}, and the Actor model. The study concluded that \ac{STM} eliminates many of the risks related to programming in shared-memory concurrency, notably deadlocks, leading into simpler reasoning and thereby easier to use. Additionally, \ac{STM} fits with the thread model used by sequential languages, and can thereby be applied to existing implementations, without requiring major rewrites. The runtime performance of \ac{STM} is at a competitive level compared to fine-grained locking\cite{dpt907e14trending}. The analysis uncovered one major caveat of \ac{STM}, it is non orthogonal with side-effects, such as \ac{IO} and exceptions\cite{dpt907e14trending}.

Despite of the apparent fit and advantages \ac{STM} could provide to sequential languages\andreas{Should be named something else}, no \ac{STM} implementation has made it into such a language. Only in Clojure\footnote{\url{http://clojuredocs.org/}} and Haskell\footnote{\url{https://wiki.haskell.org/Haskell}} has \ac{STM} been introduced as a built-in language feature. \ac{STM} has been implemented as a library based solution. In order to enable first class support, such as static code analysis and syntax support, language integration is required. With the recent event of open sourcing of the new C\# compiler\footnote{\url{https://github.com/dotnet/roslyn}} and the \ac{CLR}\footnote{\url{https://github.com/dotnet/coreclr}}, Microsoft facilitates an opportunity to extend the C\# language and compiler, and thereby opening up for integrating \ac{STM} into the language.

\section{Related Work}
This section describes related work within the areas of \ac{STM} and the Roslyn compiler. In order learn from the approaches taken by other as well as building a greater understanding of the subjects a number of papers, articles, and other research material of relevance have been read. 

In \cite{harris2005composable} Harris et al. describe their work with integration \ac{STM} into Haskell. Haskell is extend with support for an \bscode{atomic} function with takes a \ac{STM} action as input and produces a \ac{IO} action as output\cite[p. 51]{harris2005composable}. Evaluating the IO action executes the transaction defined by the atomic function. The Haskell setting allowed the authors to divide the world into \ac{STM} actions and \ac{IO} actions\cite[p. 51]{harris2005composable}, effectively disallowing \ac{IO} actions within transactions as well as only allowing \ac{STM} actions to be performed inside memory transactions. The \ac{STM} system is implemented as a C library integrated into the Haskell runtime system. The Haskell constructs utilize this library to execute transactions\cite[p. 56]{harris2005composable}. Furthermore, the authors contribute with a description and implementation of \ac{STM} constructs for conditional synchronization. The \bscode{retry} statement allows a transaction to block until some condition is met at which point the transaction is aborted and retried\cite[p. 52]{harris2005composable}. The \bscode{orElse} can be used to in combination with the retry statement to specify transactional alternatives to be executed in case the previous alternatives encounter a retry\cite[p. 52]{harris2005composable}.

\kasper[inline]{May reference last project for more detailed explanation of constructs.}

In \cite{harris2003language} the authors describe how they integrated \ac{STM} into the Java programming language by modifying both the compiler\cite[p. 4]{harris2003language} and virtual machine\cite[p. 9]{harris2003language}. The authors design, implement and Performance test a obstruction free \ac{STM} system. The \ac{STM} system uses per object ownership records to track the objects the objects version number as well as which transaction currently owns the object\cite[p. 6]{harris2003language}. Transaction descriptors are employed in order to keep track of the read and write operations performed by a transaction.
Transaction are committed  using \ac{CAS} in order to ensure atomicity\cite[p. 7]{harris2003language}.


\worksheetend