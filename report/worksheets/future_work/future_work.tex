\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Future Work}{1}{Februar 10, 2015}{Andreas}{../../}
This chapter presents possibilities for extending upon the work done in this thesis. \bsref{sec:fut_perf_test} suggests a performance test in order to examine how \stmname performs in comparison to locking in C\#. \bsref{sec:fut_inte_clr} suggests a deep \ac{STM} integration in order to achieve better performance. Finally, \bsref{sec:fut_irreversible_actions} suggests to investigate possible ways of combining  irreversible actions and \ac{STM} in the context \stmname.

\label{chap:future_work}
\section{Performance Test}\label{sec:fut_perf_test}
The focus of this thesis has been on evaluating the usability of language integrated \ac{STM} compared to that of library-based \ac{STM} and locking. As described in \bsref{sec:scope}, the performance of \ac{STM} has not yet been considered. However having language integrated \ac{STM} is not sufficient, as concurrency usually is introduced to achieve good performance. It is essential to know how \stmname performs in comparison to locking in C\#, since if it performs far worse, it is not a valid alternative, in its current state. A performance test is therefore a candidate for future work, and the outcome may result in changes to the design and underlying algorithm of \stmname, in order to improve its performance.

To investigate performance, an extensive performance suite with a number of problems or algorithms with great diversity could provide valuable insights into how the three concurrency approaches perform under varied circumstances. In this thesis, four concurrency problems have been developed, which advantageously could be included in the test suite, by measuring their performance. Furthermore a number of concurrent performance suites already exists, which could be investigated in order to help select additional problems. In \cite{imam2014savina} a performance suite, specifically for the actor model is proposed. The performance suite contains 28 test cases that \textit{``range from popular microbenchmarks to classical concurrency problems to applications that demonstrate various styles of parallelism''} which are \textit{``diversive, realistic and compute intensive''}. The dining philosophers and concurrent hashmap\footnote{Refered to as Concurrent Dictionary in the article} are also included in this performance suite. Another benchmark specifically designed for \ac{STM} is proposed in \cite{guerraoui2006stmbench7}, which uses \textit{``a set of workloads that correspond to realistic, complex, object-oriented applications which benefit from multi-threading''} to compare the performance between \ac{STM} implementations. Comparing \stmname to other \ac{STM} implementations, could give valuable insights to evaluate the relation between \ac{STM} design decisions and performance.

%\toby[i]{Maybe something from Peters article about microbenchmarks in java and C\# (http://www.itu.dk/people/sestoft/papers/benchmarking.pdf)}
%Måske noget fra Peters paper omkring performacne testing også (fra hans kursus)
	%Hvordan man skal udfører testene (antal gange osv.)
	%Antal cores? (gamle rapport havde vi noget med de fik andre resultater over xx cores)
%Valuable to know whether \stmname performs better than a regular sequential program C\#
%Some of the design choices made, may have looked different if the focus was on performance to begin with
\section{Integration into \acs{CLR}}\label{sec:fut_inte_clr}
\bsref{chap:roslyn_extension} describes how \ac{STM} is integrated into C\# by modifying the Roslyn compiler to transform the source code containing \ac{STM} language constructs to standard C\# code which utilizes the \ac{STM} library. As a result no modifications are required to the \ac{CLR} as it receives byte code in the standard \ac{CIL} format produced by the Roslyn C\# compiler's code generator.

As an alternative, a deeper integration, similar to that of \cite{harris2003language} and \cite{duffy2010stmnet}, could be utilized. One approach is to extend the \ac{CLR} and its associated byte code format \ac{CIL} with support for respectively, the execution and definition of transactions. Extending \ac{CIL} with support for the definition of transactions allow the \ac{JIT} compiler to apply further optimization to the execution of transactions. Additionally, if the executing hardware supports it, the \ac{CLR} could delegate smaller transactions to the hardware providing a performance boost.

If \ac{CIL} is extended with support for the definition of transactions, the Roslyn compiler will have to be extended as well, as the compiler must generate code utilizing the new \ac{CIL} instructions. As a result the lexing, parsing, semantic analysis and code generation of the Roslyn compiler must be extended to support the \ac{STM} constructs. However, the lexing and parsing implemented in this project can be reused for such an extension.
% Deep integration throughout the compiler (emitting new CIL instructions), and the \ac{CLR}. Could give better performance. Link to performance with Harris (Lightweight Transactions).
%
\section{Irreversible Actions}\label{sec:fut_irreversible_actions}
As described in \bsref{sec:scope}, solving the integration problems between transactions and irreversible actions, has not been an area of focus for this thesis. As irreversible actions in the context of \ac{STM} still contains a number of issues, the area could benefit from an increased research effort. \stmname offers no support of or warning against irreversible actions in transactions, which hurts its usability, as it leaves it up to the programmer to manually handle it correctly.

The integration between transactions and irreversible actions is therefore a candidate for future work, both in terms of how to manage it in \stmname, but also in terms of \ac{STM} in general. A number of possible integration approaches exist, we briefly scratched the surface in our prior study\cite[p. 51-52]{dpt907e14trending}. One approach, presented in \cite[p. 4]{harris2003language}, disallows the use of native calls inside transactions, by raising a runtime exception. A similar approach is, to enable the developer to mark a function, so the \ac{STM} system is aware of its side effect. In Clojure this is possible with the \#io macro. If a function is marked, and used in a transaction, a runtime exception will be raised. In \cite{harris2005exceptions} Harris et al. proposes another approach where \ac{IO} libraries should implement an interface, allowing the \ac{STM} system to initiate a callback when the transaction is committed, allowing the effect to be buffered until then. In \cite{duffy2010stmnet} Duffy proposes using a well known strategy from the transaction theory\cite{reuter1993transaction}, having the programmer supply on-commit and on-rollback actions to perform or compensate for the irreversible action. All of these approaches however either impose additional effort unto the programmer or completely disallow irreversible actions. A more elegant solution will benefit the area of \ac{STM} in general and may instigate the adaptation of \ac{STM} as a language feature.
%These solutions either burden the programmer using \ac{STM}, or the library designer that must implement a special interface.
\worksheetend