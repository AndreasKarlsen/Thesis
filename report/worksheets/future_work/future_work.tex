\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Future Work}{1}{Februar 10, 2015}{Andreas}{../../}
\section{Performance Test}
The focus of this thesis has not been on achieving good performance for \stmname, but rather on the integration of \ac{STM} in C\#, as described in \bsref{sec:scope}. However having a seamless integration is not sufficient, as concurrency usually is introduced to achieve good performance. It is essential to know how \stmname performs in comparison to locking in C\#, as if it performs far worse, it is not a valid alternative, in its current state.\toby{Should we talk about coarse and fine-grain locking individually in relation to performance?} A performance test is therefore an ideal candidate for future work, and the outcome may result in changes to the \ac{STM} design and underlying algorithm of \stmname in order to improve its performance.

To investigate performance, it could be valuable to make an extensive performance suite with a number of problems or algorithms with great diversity, in order to see how the individual model performs in different domains. In this thesis, three concurrency problems have already been developed, which advantageously could be included in the test suite, by measuring their performance. Furthermore there already exists a number of concurrent performance suites, which could be investigated in order to help select more problems. In \cite{imam2014savina} they propose a performance suite, specifically for the actor model, which contains 28 test cases that \textit{``range from popular microbenchmarks to classical concurrency problems to applications that demonstrate various styles of parallelism''} which are \textit{``diversive, realistic and compute intensive''}. The dining philosophers and concurrent hashmap\footnote{Refered to as Concurrent Dictionary in the article} is also included in this performance suite. Another benchmark specifically designed for \ac{STM} is proposed in \cite{guerraoui2006stmbench7}, which uses \textit{``a set of workloads that correspond to realistic, complex, object-oriented applications which benefit from multi-threading;''} to compare the performance between \ac{STM} implementations. It could be valuable to compare \stmname to other \ac{STM} implementations, in order to investigate the relation between \ac{STM} design decisions and performance.\toby{Skal vi skrive nogen? C\#: SXM og Shielded. Mest populære: Clojure og Multiverse}

\toby[i]{Maybe something from Peters article about microbenchmarks in java and C\# (http://www.itu.dk/people/sestoft/papers/benchmarking.pdf)}
%Måske noget fra Peters paper omkring performacne testing også (fra hans kursus)
	%Hvordan man skal udfører testene (antal gange osv.)
	%Antal cores? (gamle rapport havde vi noget med de fik andre resultater over xx cores)
%Valuable to know whether \stmname performs better than a regular sequential program C\#
%Some of the design choices made, may have looked different if the focus was on performance to begin with
\section{Irreversible Actions}\toby{Ved ikke det skal være i reflection}
Integration between transactions and irreversible actions, such as \ac{IO} and exceptions, is out of scope of this master thesis, as described in \bsref{sec:scope}, because they combine poorly and it is an unsolved problem how to handle it gracefully\cite{harris2005exceptions}. The result is that there is no support or warning against irreversible actions in \stmname, which hurts its usability if used in combination with irreversible actions, as it leaves it up to the programmer to manually handle it correctly, which is hard or impossible.

The integration between transaction and irreversible actions is therefore an ideal candidate for future work, both in terms of how to manage it in \stmname, but also in terms of research purposes, if it is possible to come up with new and better solutions than already exists. 

There exists a number of possible existing integration approaches, where we briefly scratched the surface in our prior study\cite[p. 51-52]{dpt907e14trending}. One approach, presented in \cite[p. 4]{harris2003language}, disallows the use of native calls inside transactions, by raising a runtime exception. A similar approach is, to enable the developer to mark a function, so the \ac{STM} system is aware of its side effect. In Clojure it is possible to do this with the \#io macro. If a function is marked, and used in a transaction, a runtime exception will be raised. In \cite{harris2005exceptions} Harris et al. proposes another approach where \ac{IO} libraries should implement an interface, allowing the \ac{STM} system to do callbacks when the transaction is committed, allowing the effect to be buffered until then. In \cite{duffy2010stmnet} Duffy proposes using a well known strategy from the transaction theory\cite{reuter1993transaction}, having the programmer supply on-commit and on-rollback actions to perform or compensate for the irreversible action.\toby{Har taget meget af det om de forskellige appraoches fra requirements, evt. slet det et af stederne}
%These solutions either burden the programmer using \ac{STM}, or the library designer that must implement a special interface.

\worksheetend
