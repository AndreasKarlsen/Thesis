\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Implementation}{0}{Februar 10, 2015}{}{../../}
This chapter describes the \ac{STM} was implemented in the C\# programming language.
\label{chap:implementation}
\section{\acs{STM} System}
\subsection{Implementation Strategies}
Various implementations strategies have been proposed for \ac{STM} of which a few where described in \bsnameref{sec:intro_related_work}. This section will cover a number of implementation strategies in greater detail in order to facility a choice of implementation strategy for \stmname. In addition the correctness criteria opacity will be described.

\ac{STM} algorithms can coarsely be divided into blocking and nonblocking algorithms\cite[p. 47]{harris2010transactional}. Blocking algorithms employ some form of locking in order to ensure atomicity while nonblocking do not\cite[p. 59]{herlihy2012art}. Nonblocking algorithms guarantee that the failure of one thread does not keep other threads from making progress\cite[p. 47]{harris2010transactional}\cite[p. 142]{herlihy1991wait}\cite[p. 59]{herlihy2012art}. This  makes it impossible to employ locking as the failure of some thread $T$, which is holding a lock, will keep other threads from acquiring the lock, and thereby from progressing. Nonblocking algorithms can further be distinguished by the progress guarantees they provide. Wait-freedom is the strongest of these, and guarantees that any thread makes progress on its own work if it keeps executing\cite[p. 124]{herlihy1991wait}\cite[p. 59]{herlihy2012art}. Lock-freedom is less strict as it only guarantees that if a thread $T$ keeps executing then some thread (not necessarily $T$) makes progress\cite[p. 47]{harris2010transactional}\cite[p. 60]{herlihy2012art}. The least strict progress guarantees is call obstruction-freedom\cite[p. 47]{harris2010transactional}\cite{herlihy2003obstruction}\cite[p. 61]{herlihy2012art}. As mentioned in \bsref{sec:intro_related_work}, obstruction-freedom guarantees that any thread which runs for long enough without encountering a synchronization conflict makes progress\cite{herlihy2003obstruction}[p. 1]. While all of these progress guarantees precludes deadlocks only wait-freedom and lock-freedom precludes livelocks\cite[p. 47]{harris2010transactional}.

\kasper[inline]{obstruction freedom useful in practice}
\kasper{pending commit, permissiveness}
\andreas[inline]{Analysis of privatization techniques is done by \cite{spear2007privatization}. Strong atomicity is the technique with less restrictions, but worst performance}
\andreas[inline]{Strong atomicity can be optimized via compile time optimizations and obtain good performance. Key is removing barriers cite \cite{hindman2006atomicity}}
\section{Compiler and Library}
\section{Static Analysis}
Side-effects, change of Atomic fields outside of TM scope.

\worksheetend