\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Implementation}{0}{Februar 10, 2015}{}{../../}
This chapter describes the implementation of the \ac{STM} system that executes transactions in \stmname. Various implementation algorithms have been proposed for \ac{STM} of which a few were briefly described in \bsnameref{sec:intro_related_work}. This chapter will cover the considerations which went into selecting an algorithm for \stmname. Specific attention is payed to the requirements and design choices made in \bsref{sec:stm_requirements} and \bsref{chap:stm_design}. Based on this overview a published algorithm will be selected. As the goal of this thesis is not to contribute with a new \ac{STM} algorithm but rather evaluate how \ac{STM} fits into the context of C\#, building on a existing algorithm is the logical choice. \andreas{Not final}
\label{chap:implementation}
\section{Implementation Criteria}
\label{sec:stm_impl_criteria}
This sections describes a number of criteria which has an influence on the choice of \ac{STM} algorithm.

\subsection{Strong Atomicity}
As described in \bsref{sec:design_strong_weak_atomicity} strong atomicity ensures atomicity between transactional and non-transactional access. As \stmnamesp is required to support strong atomicity the implementation strategy should facilitate such access.

Lazy update inherently supports non-transactional reads as the value associated with transactional variables is always the most recently committed value\cite[p. 2084]{herlihy2011tm}\cite[p. 21]{harris2010transactional}. As a result a non-transactional read can never read a non-committed value and atomicity is ensured because a single non-transactional read always reads the most recently committed value of a transactional variable. Ensuring atomicity for non-transactional reads is however also possible using eager updating, but may incur some overhead in selecting the correct value to read. \andreas{Source or explanation?}

Although non-transactional writes to transactional variables cannot conflict with one another, they must be tracked by the \ac{STM} system in order to ensure that any transactions with which they conflict are aborted and retried. \cite{hindman2006atomicity} proposes expanding non-transactional access to mini transactions allowing the \ac{STM} system to track their actions. Their approach goes even further supplying optimized non-transactional access which skips much of the unnecessary logging required for normal transactions. As \stmnamesp will benefit from using the described approach, the algorithm selected should be capable of supporting it.
 
\subsection{Conditional Synchronization}
\label{subsec:stm_impl_selection_conditional}
The \bscode{retry} construct described in \bsref{sec:req_conditional} requires knowledge of which transactional variables have been read, up to the point where a retry is requested\cite{harris2005composable}. The \ac{STM} system needs to maintain a set of transactional variables which has been read, for all active transactions, so that a transaction can be blocked until one of these variables change. Such a set is often referred to as a read-set\cite{dice2006transactional}\cite{harris2010transactional}\cite{herlihy2012art}. \ac{STM} systems employing lazy conflict detection commonly use such a set to record reads for validation when the transaction is about to commit\cite{dice2006transactional}\cite{mohamedin2013bytestm}. Choosing an algorithm which already maintains a read-set will limit the overhead of the \bscode{retry} statement as well as simplify the implementation as the algorithm must not be modified to support the accumulation of a read-set. Thus selecting a algorithm which inherently supports a read-set should be a priority.

\subsection{Library Implementation}
As described in \bsref{}\kasper{HUSK REFERENCE!} the \ac{STM} system of \stmnamesp must be implemented as a .NET library. The strategy employed must not entail details which require changes to the runtime system as seem by a number of \ac{STM} implementations\cite{mohamedin2013bytestm}\cite{harris2003language}. Furthermore we aim at providing a library with an \ac{API} that facilitates use from both compiler generated code and regular C\# programs.

\subsection{Progress Guarantee}
\ac{STM} algorithms can coarsely be divided into blocking and non-blocking algorithms\cite[p. 47]{harris2010transactional}. Blocking algorithms employ some form of locking in order to ensure atomicity while non-blocking do not\cite[p. 59]{herlihy2012art}. Non-blocking algorithms guarantee that the failure of one thread does not keep other threads from making progress\cite[p. 47]{harris2010transactional}\cite[p. 142]{herlihy1991wait}\cite[p. 59]{herlihy2012art}. This  makes it impossible to employ locking as the failure of some thread $T$, which is holding a lock, will keep other threads from acquiring the lock, and thereby from progressing. Non-blocking algorithms can further be distinguished by the progress guarantees they provide. 
\begin{itemize}
	\item Wait-freedom is the strongest of these, and guarantees that any thread makes progress on its own work if it keeps executing\cite[p. 124]{herlihy1991wait}\cite[p. 59]{herlihy2012art}. 
	\item Lock-freedom is less strict as it only guarantees that if a thread $T$ keeps executing then some thread (not necessarily $T$) makes progress\cite[p. 47]{harris2010transactional}\cite[p. 60]{herlihy2012art}. 
	\item The least strict progress guarantee is obstruction-freedom\cite[p. 47]{harris2010transactional}\cite{herlihy2003obstruction}\cite[p. 61]{herlihy2012art}. As mentioned in \bsref{sec:intro_related_work}, obstruction-freedom guarantees that any thread which runs for long enough without encountering a synchronization conflict makes progress\cite[p. 1]{herlihy2003obstruction}. 
\end{itemize}
Any wait-free algorithm is also lock-free and any lock-free algorithm is also obstruction-free, but not vice versa\cite[p. 60]{herlihy2012art}. While all of these progress guarantees precludes deadlocks, only wait-freedom and lock-freedom precludes livelocks\cite[p. 47]{harris2010transactional}. Obstruction free algorithms have been shown to provide efficient implementations in practice\cite[p. 61]{herlihy2012art}, especially when paired with techniques such as exponential backoff\cite[p. 147]{herlihy2012art} and contention managers\cite[p. 51]{harris2010transactional}.

Whether \ac{STM} implementations need to be wait-free, lock-free, obstruction-free or even provide any of these guarantees at all is a ongoing discussion. Arguments have been made for even obstruction-freedom being too strong a guarantee and that \ac{STM} can be made faster by employing controlled locking\cite{ennals2006software}. Due to the complexities associated with non-blocking algorithms\cite{al2013nonblocking}\cite[p. 61]{herlihy2012art} and the evidence that blocking \ac{STM} systems can perform in practice, we initially choose to focus on blocking \ac{STM} algorithms. We do however keep the option of moving to a non-blocking algorithm at a later point open, as demonstrated by,  \cite{fernandes2011lock}.

%Older \ac{STM} systems tend to be either lock-free or obstruction-free\cite[p. 47]{harris2010transactional} while blocking \ac{STM} systems have emerged in an attempt to tune performance\cite[p. 51]{harris2010transactional}.


\section{Selection of Algorithm}
%%Choice of implementation based on previous sections and requirements
%TL2 \cite{dice2006transactional}\\
%TinySTM \cite{felber2008dynamic}\\
%McRT \cite{saha2006mcrt}\\
%JVSTM \cite{cachopo2007development}\\
%JVSTM-lock-free\cite{fernandes2011lock}\\
%\cite{herlihy2003software}\\
%\cite{hendler2011nonblocking} lockfree starve.

By investigating a number of different \ac{STM} implementations the field, on which the final selection is based, was narrowed down to McRT \cite{saha2006mcrt} developed by Saha et. al., TL2 developed by Dice et al and JVSTM developed by Cachopo. McRT and TL2 are well know in the research community and JVMSTM is a newer implementation. All of these systems employ locking but in different ways. The algorithms wary greatly in other areas and will provide a varied perspective.

\subsection{McRT}
\label{sec:stm_impl_mcrt}
McRT employees encounter time locking and supports two algorithms for synchronization\cite[p. 189]{saha2006mcrt}. The first is based on readers-writer locks that allows multiple readers to hold the lock simultaneously, while writers must have exclusive access\cite[p. 189]{saha2006mcrt}. The second is based on versioned locks where each lock has a associated version number\cite[p. 108]{harris2010transactional}. We focus only on the second approach as this has been shown to have the best performance\cite[p. 190]{saha2006mcrt}. 

McRT uses eager updates as this avoids having to check a write-set for a non-committed version of an item, when a read to that item occurs\cite[p. 109]{harris2010transactional}. Locking allows the system to guarantee that no transaction reads a value which has not yet been committed\cite[p. 108]{harris2010transactional}. Eager updates requires the system to maintain a undo list which keeps track of the old values of any items to which a given transaction has written. The undo list is used to revert any items, to which a given transaction has written, to their previous state in case of an abort\cite[p. 189]{saha2006mcrt}. Eager updating makes the commit phase faster as no writes have to be redone\cite[p. 190]{saha2006mcrt}. The versioned lock algorithm of McRT requires maintaining a read-set which must be validated as part of the commit process, just as it was the case for TL2. The read-set contains a record of every item that was read as well as the version number of the item at the time of reading. During the commit phase the read-set of a transaction is validated, ensuring that no read item has a higher version number that the version number which was present when the item was read\cite[p. 190]{saha2006mcrt}.

McRT detects conflicts only against active transactions\cite[p. 189]{saha2006mcrt}. Aborting transactions due to a conflict with a active transaction can lead to cases where a transaction \bscode{t1} is aborted due to a conflict with a \ac{t2} transaction, but \bscode{t2} is aborted before it can commit due a conflict with some transaction \bscode{t3}\cite[p. 2084]{herlihy2011tm}. As such \bs{t1} could have been allowed to continue as the transaction with which it conflicted never committed. 

Conflicts between transactions appear as contention on the locks in the system. If multiple transactions attempt to acquire a lock on the same item a conflict is about to occur. In such cases McRT prefers letting transaction wait for the lock over aborting one of the involved transactions, in order to increase throughput\cite[p. 189]{saha2006mcrt}.

\subsection{TL\rom{2}}
As briefly described in \bsref{sec:intro_related_work}, only holds locks during the commit process\cite[p. 199]{dice2006transactional}. This is known as commit time locking. TL2 uses lazy updates where writes are recorded in a write-set and written to the associated memory when the transaction commits. Additionally any reads performed by a transactions is recorded in a read-set which is used to validate the transaction before it commits the contents of its write-set\cite[p. 198]{dice2006transactional}. The accumulation of a read-set for the \bscode{retry} will therefor incur no additional overhead.

TL2 uses a global version clock to ensure atomicity\cite[p. 201]{dice2006transactional}. Transaction record a time-stamp when they start. The time-stamp is used to validate the contents of the read-set before the transaction commits. Each item tracked by the \ac{STM} system, has a associated time-stamp which is updated when a transaction commits a new value. If any item in the read-set has a time-stamp which is higher than transactions time-stamp then the item has been modified while the transaction was executing. As a result the transaction must abort and restart.

In order to commit, a transaction must go trough the following steps\cite[p. 200]{dice2006transactional}:
\begin{enumerate}
\item Acquire the lock on items in the write-set
\item Increment and fetch the version clock
\item Validate the read-set as described above
\item Commit values in the write-set along with the new time-stamps
\item Release the lock on items in the write-set
\end{enumerate}
As such the transaction has exclusive access to the items in the write set during the commit phase and detects conflicts lazily against previously committed transactions. 

The version clock can be a source of contention as all transactions must increment version clock as part of the commit operation\cite[p. 120]{harris2010transactional}. A number of ways of reducing contention has been proposed \cite{zhang2008commit}\cite{lev2009anatomy}\cite{avni2008maintaining}.

The base TL2 algorithm can lead to false negatives when validating the read-set. If a transaction \bscode{t2} executes between transaction \bscode{t1} reading the global clock and reading its first value. \bscode{t2} will then have incremented the version clock and the time-stamp of \bscode{t1} will be invalid before it starts executing its transaction, even though the transaction would be valid if it occurred after \bscode{t2}. In \cite{riegel2007time} it is proposes to attempt to upgrade a transactions time-stamp in to eliminates such false negatives.

\subsection{JVSTM}
JVSTM uses \ac{MVCC}\cite[p. 1]{fernandes2011lock}, as known of databases\cite[p. 791]{elmasri2011fundamentals}. \ac{MVCC} requires the \ac{STM} system to keep a record of the old values for any item that is tracked\cite[p. 791]{elmasri2011fundamentals}. Reads that would be invalid in a system maintaining only the most recent value for each item, can be redirected to read an older value, allowing the associated transaction to continue\cite[p. 791]{elmasri2011fundamentals}. As a result JVSTM guarantees that read only transaction will always be able to commit\cite[p. 97]{cachopo2007development}.

To keep track of a the values associated with an item JVSTM uses what original designer calls a versioned box\cite[p. 63]{cachopo2007development}. A version box is abstraction for a item that is to be tracked, such as a variable. Each version box keeps a ordered sequence of values, called the history of the versioned box. This ordered sequence represents the values that have been committed to the item. Each transaction and version in the history of a versioned box is assgined a version number indicating when the transaction started and when the value was created.

JVSTM uses lazy updates, buffering writes in a transaction local write-set\cite[p. 64]{cachopo2007development}. As with TL2 writes are written to the tracked item when the transaction commits. Reads from a versioned box first checks if the transactions write-set contains a non committed, returning it if that is the case\cite[p. 64]{cachopo2007development}. If no such item exists the history of the versioned box is searched for a suitable value. The first value that has a version number less than or equal to the transactions versioned number is returned\cite[p. 64]{cachopo2007development}.

The base variation of JVSTM uses a single global lock to ensure atomicity between committing transactions\cite[p. 70]{cachopo2007development}, forcing the commit phase to be executed sequentially even though two transactions may not be committing to the same versioned boxes. A lock-free variation JVSTM, correcting this issue, is proposed in \cite{fernandes2011lock}.

Keeping the old values for each tracked item takes up additional space and the space consumption increases as new versions are added. Over time some old values might no longer be needed and can therefor be removed. To handle this JVSTM implements a thread responsible for this task\cite[p. 70]{cachopo2007development}\cite[p. 88]{cachopo2007development}, similar to a garbage collector\cite[p. 472]{fischer2009crafting}.

%read of values
\subsection{Final Selection}
Based on the criteria presented in \bsref{sec:stm_impl_criteria}, the requirements defined in \bsref{sec:stm_requirements} and the intended design presented in \bsref{chap:stm_design} it has been selected to base the \ac{STM} implementation on the TL2 algorithm. 

TL2 uses lazy updating simplifying the implementation of strong atomicity as non-transactional read can access values directly. Additionally the algorithm makes use of a read-set simplifying the implementation of the \bscode{retry} construct. A extension to TL2 allowing it to support opacity is presented in \cite[p. 107]{harris2010transactional} fufilling the requirement presented in \bsref{sec:stm_req_opacity}. Furthermore the TL2 algorithms is well documented from multiple sources, including a library based implementation\cite{dice2006transactional}\cite[p. 438]{herlihy2012art}\cite[p. 106]{harris2010transactional}.

McRT was discarded as its eager updating strategy based on locking may require non-transactional reads to wait. If a active transaction \bscode{t1} has written a value to some variable \bscode{x} and a non-transactional read to \bscode{x} occurs, the non-transactional read would have to wait for \bscode{t1} to finish in order to ensure that the value read is not rolled back at a later point. Additionally conflict detection against active transaction can lead to unnecessary aborts as described as described in \bsref{sec:stm_impl_mcrt}.

JVSTM's use of the well know \ac{MVCC} approach to transactions facilitates a guarantee that read only transaction will always be able to commit. While this is an attractive property \ac{MVCC} also requires a garbage collection thread tasked with removing old values that can no longer be read, thereby complicating the implementation. Additional the lock based version of JVSTM uses commit phases which executes sequentially due to global locking. As a result the scalability of the  JVSTM algorithm is reduced\cite[p. 86]{cachopo2007development}. 
%opacity


%\subsubsection{DSTM}
%By investigating a number of different \ac{STM} implementations the field, on which the final selection is based, was narrowed down to the obstruction-free DSTM presented in \cite{herlihy2003software}, the lock-free variation of JVSTM presented in \cite{fernandes2011lock} and lock based TL2 presented in \cite{dice2006transactional}. All of these implementations contribute with a \ac{STM} library intended to be used directly by the programmer\cite[p. 92]{herlihy2003software}\cite[p. 73]{cachopo2007development}\cite[p. 38]{lourencco2007testing}. DSTM was selected based on its impact on both obstruction-free \ac{STM} and  \ac{STM} in general. JVSTM was selected as it represents a lock-free \ac{STM} system build for the Java programming language, which has a number of similarities with C\#.
%
%As briefly described in \bsref{sec:intro_related_work}, DSTM is a obstruction-free \ac{STM} library for the Java and C++ programming languages. DSTM uses transactional objects which encapsulate regular objects and provide transactional access. Conflict detection occurs at object level which is the opposite of the requirement defined in \bsref{sec:tracking}. The value of a transactional object is represented by a locator object which is updated using a Compare-And-Swap operation\cite{herlihy2003software}[p. 95]. The locator contains a reference to the transaction which installed the locator, a new value and a old value. Based on the status of the transaction which installed the current locator a reading transaction can choose to read the old or new value. If the status is \bscode{Committed} the new value is the correct value, if the status is \bscode{Aborted} the old value is the correct value. The case where the status is \bscode{Active} indicates that a conflict is about to occur and that the involved transactions should contact the contention manager in order to resolve the conflict\cite{herlihy2003software}[p. 97]. As such the implementation employees eager updating and eager conflict detection\cite[p. 96]{herlihy2003software}. Committing and a aborting a transaction is reduced to changing the status of a transaction to \bscode{Commited} or \bscode{Aborted} using a Compare-and-Swap operation. Each transactional object will have the status associated with its locator changed by the same operation
%
%Non-transactional reads can be supported by choose the correct value to read. A read can occur similar to a transactional read. That is reading the new value if the status is \bscode{Committed} or the old value if status is \bscode{Aborted}. If the status is \bscode{Active} the old value should be read, causing the non-transactional read to occur before the transaction which installed the current locator. Choosing the correct value to read, as opposed to simply reading the most recently committed value which lazy updating allows, does however cause some overhead. Non-transactional writes can be accomplished by expanding the writes to mini transactions as described in \bsref{subsec:stm_impl_selection_conditional}.
%
%The base algorithm has no need for a read-set as any read is communicated to other transactions by installing a new locator specifying that the transaction has accessed the transactional object. Supporting the \bscode{retry} construct requires adding support for a read-set by modifying the existing algorithm.
%%Object based conflict detection.
%
%The base DSTM algorithm does not support concurrent reads as the locator objects does not allow distinguishing a read from a write operation\cite[p. 435]{herlihy2012art}. As concurrent reads is one of the major advantages offered by \ac{STM}'s optimistic approach to shared memory concurrency, the algorithm must be modified to support such operations in order to be useful in practice.

\section{STM Algorithm}
Description of selected algorithm.
%Avoiding deadlocks.

\section{Implementation Description}
Key parts of the implementation including code examples.

\kasper[inline]{obstruction freedom useful in practice}
\kasper[inline]{pending commit, permissiveness}
\andreas[inline]{Analysis of privatization techniques is done by \cite{spear2007privatization}. Strong atomicity is the technique with less restrictions, but worst performance}
\andreas[inline]{Strong atomicity can be optimized via compile time optimizations and obtain good performance. Key is removing barriers cite \cite{hindman2006atomicity}}
\andreas[inline]{In some cases, the order of reading values must be enforced. The compiler will reorder the value readings, and the volatile keyword must be used to enforce no optimizations from the compiler. Example \cite[p. 35]{harris2010transactional}}.
\andreas[inline]{We must handle interoperation with binaries using our library. They will be translated, and not annotated with atomic keywords. We must accommodate this when designing the compiler, to ensure interaction with atomicsharp works.}
\worksheetend