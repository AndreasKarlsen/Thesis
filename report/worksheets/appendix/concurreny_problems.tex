\chapter[]{Concurrency Problems}
\section{Dining Philosophers}\label{app:dining_phil}
The Dining Philosophers problem is defined as follows:
\bsqoute{Five philosophers spend their lives thinking and eating. The philosophers share a common dining room where there is a circular table surrounded by five chairs, each belonging to one philosopher. In the center of the table there is a large bowl of spaghetti, and the table is laid with five forks (see \bsref{fig:dining_philosophers}). On feeling hungry, a philosopher enters the dining room, sits in his own chair, and picks up the fork on the left of his place. Unfortunately, the spaghetti is so tangled that he needs to pick up and use the fork on his right as well. When he has finished, he puts down both forks, and leaves the room. The room should keep a count of the number of philosophers in it.}{Edgar Dijkstra\cite[p. 673]{hoare1978communicating}}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.7\textwidth]{\rootpath/worksheets/appendix/figures/dining_philosophers}
\caption{The Dining Philosophers}
\label{fig:dining_philosophers}
\end{figure}

\section{The Santa Claus Problem}\label{app:santa}
The Santa Claus problem is defined as follows:
\bsqoute{Santa Claus sleeps in his shop up at the North Pole, and can only be wakened by either all nine reindeer being back from their year long vacation on the beaches of some tropical island in the South Pacific, or by some elves who are having some difficulties making the toys. One elf's problem is never serious enough to wake up Santa (otherwise, he may \b{never} get any sleep), so, the elves visit Santa in a group of three. When three elves are having their problems solved, any other elves wishing to visit Santa must wait for those elves to return. If Santa wakes up to find three elves waiting at his shop's door, along with the last reindeer having come back from the tropics, Santa has decided that the elves can wait until after Christmas, because it is more important to get his sleigh ready as soon as possible. (It is assumed that the reindeer don't want to leave the tropics, and therefore they stay there until the last possible moment. They might not even come back, but since Santa is footing the bill for their year in paradise â€¦ This could also explain the quickness in their delivering of presents, since the reindeer can't wait to get back to where it is warm.) The penalty for the last reindeer to arrive is that it must get Santa while the others wait in a warming hut before being harnessed to the sleigh.}{John A. Trono\cite{trono1994new}}

\section{Concurrent Queue}\label{app:queue}
A queue is a \ac{FIFO} data structure, operating like the queue at a cash register\cite[p. 234]{cormen2009introduction}. A queue supports the operations \bscode{Enqueue} and \bscode{Dequeue}. \bscode{Enqueue} inserts an item at the back of the queue while \bscode{Dequeue} gets and removes the item at the front of the queue, per the \ac{FIFO} principle. A queue is commonly implemented using a linked list of nodes\cite[p. 234]{cormen2009introduction}. To be able to enqueue and dequeue, the queue holds a reference to the first and last node in the list, referred to as the head and tail of the queue.
\section{Concurrent HashMap}\label{app:hashmap}
A HashMap is a data structure which allows looking up values based on their associated key and provides the operations Add, Get, and Remove. It benefits from the Get operation having an average time complexity of \textit{O}(1) under reasonable assumptions\cite[p. 256]{cormen2009introduction}. Implementation details of a HashMap may vary, but traditionally they follow the concept described in\cite[p. 256]{cormen2009introduction}. Internally it uses an array for storing a list of key/value pairs. When inserting a value into the HashMap, the  array index is commonly calculated as:
\begin{equation}
Hash(key) \bmod arraylength
\end{equation}
That is, a hash function applied to the key, modulo the size of the backing array. If another key is already stored in the array index calculated, it is said to be a collision. To handle this, the value is not stored directly in the array index, but in a list referred to as a bucket. This bucket is implemented as a linked list as this ensures fast insertions\cite[p. 257]{cormen2009introduction}. Index based lookup and removal is not needed as the index of a particular key is not known. Therefore it is always required to iterate through the bucket list when searching for a particular key. The calculation of the bucket index must distribute the values evenly to lessen the collisions. When a certain percentage of the buckets are filled, the internal array must be resized to keep the risk of collisions low. This internal operation is expensive in terms of both time and space, as a new internal array of an increased size must be allocated, and the key/value pairs must be inserted into the new array.
