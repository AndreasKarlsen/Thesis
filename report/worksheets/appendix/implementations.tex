\chapter[]{Appendix Evaluation Implementations}
This appendix presents the implementations of the selected problems, described in \bsref{sec:eval_approach}, on which the evaluation presented in \bsref{chap:evaluation} is based. Along with each implementation follows a brief description.
\label{app:eval_implementations}

\section{Lock-Based}\label{app:impl_lockbased}
This sections presents the lockbased implementations of the selected problems.

\subsection{Dining Philosophers Problem}
The lock based implementation of the dining philosophers problem requires the use of the \bscode{Monitor} class to acquire the second lock with a time out on line \ref{line:dining_lock_try}. As a result a \bscode{try/finally} block is used, on lines \ref{line:dining_lock_try_finally_start} to \ref{line:dining_lock_try_finally_end}, to ensured that the acquired lock is released in case an error occurs while the lock is held.
\begin{lstlisting}[label=lst:impl_dining_lock,
  caption={Lock based dining philosophers Iimplementation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  escapechar=~,
  morekeywords={atomic, retry, orelse, var, get, set, ref, out, readonly, virtual, override, lock}]  % Start your code-block

  public class LockingDiningPhilosophers
  {
  	public static void Start()
  	{
      var fork1 = new object();
      var fork2 = new object();
      var fork3 = new object();
      var fork4 = new object();
      var fork5 = new object();

      var t1 = StartPhilosopher(fork1, fork2);
      var t2 = StartPhilosopher(fork2, fork3);
      var t3 = StartPhilosopher(fork3, fork4);
      var t4 = StartPhilosopher(fork4, fork5);
      var t5 = StartPhilosopher(fork5, fork1);

      t1.Join();
      t2.Join();
      t3.Join();
      t4.Join();
      t5.Join();
    }

    private static Thread StartPhilosopher(object left, object right)
    {
      var t1 = new Thread(() =>
      {
        while (true)
        {
          lock (left)
          {
          
            var lockTaken = false;
            try~\label{line:dining_lock_try_finally_start}~
            {
              Monitor.TryEnter(right, 100, ref lockTaken);~\label{line:dining_lock_try}~
              if (lockTaken)
              {
                Console.WriteLine("Thread: " + Thread.CurrentThread.ManagedThreadId + " eating.");
                Thread.Sleep(100);
              }
            }
            catch (Exception)
            {
              if (lockTaken)
              {
                Monitor.Exit(right);
              }
            }~\label{line:dining_lock_try_finally_end}~
          }

          Thread.Sleep(100);
        }
      });

      t1.Start();
      return t1;
    }
  }
  
\end{lstlisting}

\subsection{Santa Claus Problem}
As seen on line \ref{line:santa_lock_santa_sem}, the lock based Santa Claus problem implementation uses a semanphore to allow the elfs and reindeer to wake Santa given their respective conditions are true. When Santa is awoken he must check whether he was awoken by the elfs or by the reindeer, as shown on lines \ref{line:santa_lock_santa_check_start} to \ref{line:santa_lock_santa_check_end}. As the reindeer must take priority, as defined in \bsbilagref{app:santa}, their condition is checked in order to determine the action which Santa takes. Similarly, as shown on line \ref{line:santa_lock_elf_wait}, the elfs utilize a semaphore to ensure that only three elfs go to santa at a time. As shown on lines \ref{line:santa_lock_elf_queue_start} to \ref{line:santa_lock_elf_queue_end} as well as \ref{line:santa_lock_reindeer_queue_start} to \ref{line:santa_lock_reindeer_queue_end}, both the elfs and the reindeer enqueue themselves and check their condition while holding a lock on their respective queues, ensuring that only a single thread observes the condition as true and notifies Santa.

\begin{lstlisting}[label=lst:impl_santa_lock,
  caption={Lock based Santa Clause Implementation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  escapechar=~,
  morekeywords={atomic, retry, orelse, var, get, set, ref, out, readonly, virtual, override, lock}]  % Start your code-block

  public class LockingSantaClausProblem
  {
    public static void Start()
    {
      var santaHandle = new SemaphoreSlim(0,2); 
      var sleigh = new SemaphoreSlim(0,SCStats.NR_REINDEER);
      var warmingHut = new SemaphoreSlim(0, SCStats.NR_REINDEER);
      var reindeerDone = new SemaphoreSlim(0, SCStats.NR_REINDEER);
      var elfWaiting = new SemaphoreSlim(0, SCStats.MAX_ELFS);
      var elfDone = new SemaphoreSlim(0, SCStats.MAX_ELFS);
      var maxElfs = new SemaphoreSlim(SCStats.MAX_ELFS, SCStats.MAX_ELFS);
      var rBuffer = new Queue<LockingReindeer>();
      var eBuffer = new Queue<LockingElf>();
      var santa = new LockingSanta(rBuffer,eBuffer,santaHandle,sleigh, warmingHut,reindeerDone,elfWaiting, elfDone);
      santa.Start();

      for (var i = 0; i < SCStats.NR_REINDEER ; i++)
      {
        var reindeer = new LockingReindeer(i, rBuffer, santaHandle, sleigh, warmingHut, reindeerDone);
        reindeer.Start();
      }
            
      for (var i = 0; i < SCStats.NR_ELFS; i++)
      {
        var elf = new LockingElf(i, eBuffer,santaHandle,maxElfs,elfWaiting,elfDone);
        elf.Start();
      }
    }
  }
  
  public class LockingSanta : IStartable
  {
    private readonly Queue<LockingReindeer> _rBuffer;
    private readonly Queue<LockingElf> _eBuffer;
    private readonly SemaphoreSlim _santaHandle;
    private readonly SemaphoreSlim _sleigh;
    private readonly SemaphoreSlim _warmingHut;
    private readonly SemaphoreSlim _reindeerDone;
    private readonly SemaphoreSlim _elfsWaiting;
    private readonly SemaphoreSlim _elfsDone;

    public LockingSanta(Queue<LockingReindeer> rBuffer, Queue<LockingElf> eBuffer, SemaphoreSlim santaHandle,
            SemaphoreSlim sleigh, SemaphoreSlim warmingHut, SemaphoreSlim reindeerDone, SemaphoreSlim elfsWaiting, SemaphoreSlim elfsDone)
    {
      _rBuffer = rBuffer;
      _eBuffer = eBuffer;
      _santaHandle = santaHandle;
      _sleigh = sleigh;
      _warmingHut = warmingHut;
      _reindeerDone = reindeerDone;
      _elfsWaiting = elfsWaiting;
      _elfsDone = elfsDone;
    }

    public Task Start()
    {
      return Task.Run(() =>
      {
        while (true)
        {
          //Santa is resting
          _santaHandle.Wait();~\label{line:santa_lock_santa_sem}~

          var wakeState = WakeState.ElfsIncompetent;

          lock (_rBuffer)~\label{line:santa_lock_santa_check_start}~
          {
            if (_rBuffer.Count == SCStats.NR_REINDEER)
            {
              wakeState = WakeState.ReindeerBack;    
            }
          }~\label{line:santa_lock_santa_check_end}~

          switch (wakeState)
          {
            case WakeState.ReindeerBack:
              Console.WriteLine("All reindeer are back!");

              //Release reindeers from warming hut
              _warmingHut.Release(SCStats.NR_REINDEER);

              //Setup the sleigh
              _sleigh.Release(SCStats.NR_REINDEER);

              //Deliver presents
              Console.WriteLine("Santa delivering presents");
              Thread.Sleep(100);

              //Release reindeer
              _rBuffer.Clear();
              _reindeerDone.Release(SCStats.NR_REINDEER);
              Console.WriteLine("Reindeer released");
              break;
            case WakeState.ElfsIncompetent:
              Console.WriteLine("3 elfs at the door!");

              _elfsWaiting.Release(SCStats.MAX_ELFS);

              //Answer questions
              Thread.Sleep(100);

              //Back to work incompetent elfs!
              _eBuffer.Clear();
              _elfsDone.Release(SCStats.MAX_ELFS);

              Console.WriteLine("Elfs helped");
              break;
          }
        }
      });
    }
  }
  
  public class LockingElf : IStartable
  {
    private readonly Random _randomGen = new Random(Guid.NewGuid().GetHashCode());
    public int ID { get; private set; }
    private readonly Queue<LockingElf> _buffer;
    private readonly SemaphoreSlim _maxElfs;
    private readonly SemaphoreSlim _santaHandle;
    private readonly SemaphoreSlim _waitingToAsk;
    private readonly SemaphoreSlim _doneAsking;

    public LockingElf(int id, Queue<LockingElf> buffer, SemaphoreSlim santaHandle, SemaphoreSlim maxElfs, SemaphoreSlim waitingToAsk, SemaphoreSlim doneWaiting)
    {
      _buffer = buffer;
      ID = id;
      _maxElfs = maxElfs;
      _santaHandle = santaHandle;
      _waitingToAsk = waitingToAsk;
      _doneAsking = doneWaiting;
    }

    public Task Start()
    {
      return Task.Run(() =>
      {
        while (true)
        {
          Thread.Sleep(100 * _randomGen.Next(21));

          //Only a fixed amount of elfs can go to santa at a time
          _maxElfs.Wait();~\label{line:santa_lock_elf_wait}~

          lock (_buffer)~\label{line:santa_lock_elf_queue_start}~
          {
            _buffer.Enqueue(this);
            if (_buffer.Count == SCStats.MAX_ELFS)
            {
              _santaHandle.Release();
            }
          }~\label{line:santa_lock_elf_queue_end}~

          Console.WriteLine("Elf {0} at the door", ID);

          //Wait for santa to be ready
          _waitingToAsk.Wait();

          //Asking questions
          _doneAsking.Wait();

          //Allow a new elf to visit santa
          _maxElfs.Release();
        }
      });
    }

    public void AskQuestion()
    {
      _waitingToAsk.Release();
    }
  }
  
  public class LockingReindeer : IStartable
  {
    private readonly Random _randomGen = new Random(Guid.NewGuid().GetHashCode());
    public int ID { get; private set; }

    private readonly Queue<LockingReindeer> _reindeerBuffer;
    private readonly SemaphoreSlim _santaHandle;
    private readonly SemaphoreSlim _sleigh;
    private readonly SemaphoreSlim _doneDelivering;
    private readonly SemaphoreSlim _warmingHut;

    public LockingReindeer(int id, Queue<LockingReindeer> buffer, SemaphoreSlim santaHandle, SemaphoreSlim sleigh, SemaphoreSlim warmingHut, SemaphoreSlim doneDelivering)
    {
      ID = id;
      _reindeerBuffer = buffer;
      _santaHandle = santaHandle;
      _sleigh = sleigh;
      _warmingHut = warmingHut;
      _doneDelivering = doneDelivering;
    }

    public Task Start()
    {     
      return Task.Run(() =>
      {
        while (true)
        {
          //Tan on the beaches in the Pacific until Chistmas is close
          Thread.Sleep(100 * _randomGen.Next(10));

          lock (_reindeerBuffer)~\label{line:santa_lock_reindeer_queue_start}~
          {
            _reindeerBuffer.Enqueue(this);
            if (_reindeerBuffer.Count == SCStats.NR_REINDEER)
            {
              _santaHandle.Release();
            }
          }~\label{line:santa_lock_reindeer_queue_end}~

          //Console.WriteLine("Reindeer {0} is back",ID);

          //Block early arrivals
          _warmingHut.Wait();

          //Wait for santa to be ready
          _sleigh.Wait();

          //Delivering presents

          //Wait for delivery to be done
          _doneDelivering.Wait();
          //Head back to Pacific islands
        }
      });
    }
  }
  
\end{lstlisting}

\subsection{Concurrent Queue}
The lock based queue implementation is based on Michael L Scott's lock-based queue algorithm described in \cite{michael1996simple}. The implementation uses two locks, as seen on lines \ref{line:queue_lock_taillock} and \ref{line:queue_lock_headlock}, to protect the tail and head of the queue respectively. The first node in the queue is a dummy node which allows the enqueue and dequeue operations to only operate on the tail and head respectively, thereby allowing enqueuing and dequeuing to occur concurrently. Only a single enqueue or dequeue operation can however execute at at time, due to the use of locking. The dummy node is created by the queue's constructor on line \ref{line:queue_lock_dummynode}.

\begin{lstlisting}[label=lst:impl_queue_lock,
  caption={Lock based Concurrent Queue Implementation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  escapechar=~,
  morekeywords={atomic, retry, orelse, var, get, set, ref, out, readonly, virtual, override, lock}]  % Start your code-block

  public class Queue<T> : IQueue<T>
  {
    protected readonly object HeadLock = new object();
    protected readonly object TailLock = new object();
    private Node _head;
    private Node _tail;

    public Queue()
    {
      _head = new Node(default(T));~\label{line:queue_lock_dummynode}~
      _tail = _head;
    }

    public void Enqueue(T item)
    {
      var node = new Node(item);
      lock (TailLock)~\label{line:queue_lock_taillock}~
      {
        _tail.Next = node;
        _tail = node;
      }
    }

    public bool Dequeue(out T item)
    {
      lock (HeadLock)~\label{line:queue_lock_headlock}~
      {
        var newHead = _head.Next;
        if (newHead == null)
        {
          item = default(T);
          return false;
        }

        _head = newHead;
        item = newHead.Value;
        return true;
      }
    }

    private class Node
    {
      public Node Next { get; set; }
      public T Value { get; private set; }

      public Node(T value)
      {
        Value = value;
      }
    }
  }

\end{lstlisting}

\subsection{Concurrent Hasmap}
The lock-based concurrent hashmap implementation is based on the concept of lock striping. Lock striping allows $L$ locks to protect $B$ buckets where $B \geq L$ and $B \bmod L = 0$ so that each lock $l$ protects each bucket $b$ where $indexof(b) = indexof(l) \bmod L$\cite[p. 304]{herlihy2012art}. When the number of buckets is doubled as a result of resizing the hashmap the same lock protects a particular bucket before and after the resize completes. The buckets protected by a particular lock are referred to as a stripe and multiple stripes can be accessed concurrently.

Along with the backing array of buckets defined on line \ref{line:hashmap_lock_array} a array of objects representing the locks is defined on line \ref{line:hashmap_lock_locks}. Before a thread access a bucket it must acquire the lock on the stripe containing the bucket in question. As an example, the \bscode{Add} method defined on line \ref{line:hashmap_lock_add} calculates the index of the lock to acquire on line \ref{line:hashmap_lock_lockindex} before adding the item to the bucket. The \bscode{ResizeIfNeeded} method defined on line \ref{line:hashmap_lock_resize} acquires the lock on all stripes on line \ref{line:hashmap_lock_resize_lock} ensuring that no other threads are accessing the backing array while it is being resized. The condition for resizing is checked before all locks are acquired on line \ref{line:hashmap_lock_resize_cond_before} as well as again after all locks have been acquired on line \ref{line:hashmap_lock_resize_cond_after}, ensuring that only a single thread resizes the backing array for every instance where a resize is required. The object defined on line \ref{line:hashmap_lock_size_lock} protect the \bscode{\_size} variable defined on line \ref{line:hashmap_lock_size}. This is required as multiple threads can add or remove items to different stripes simultaneously requiring their access to the \bscode{\_size} variable to be synchronized.

\begin{lstlisting}[label=lst:impl_hashmap_lock,
  caption={Lock based Concurrent Hasmap Implementation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  escapechar=~,
  morekeywords={atomic, retry, orelse, var, get, set, ref, out, readonly, virtual, override, region, endregion, foreach, lock}]  % Start your code-block

  public class LockingHashMap<K,V> : BaseHashMap<K,V>
  {
    private const int DefaultNrLocks = DefaultNrBuckets;

    private readonly object _sizeLock = new object();~\label{line:hashmap_lock_size_lock}~
    private readonly object[] _locks;~\label{line:hashmap_lock_locks}~
    private Node[] _buckets;~\label{line:hashmap_lock_array}~
    private int _size;~\label{line:hashmap_lock_size}~
    private int _threshold;

    public LockingHashMap() : this(DefaultNrBuckets){}

    public LockingHashMap(int size) : this(size, DefaultNrLocks){}

    private LockingHashMap(int size, int nrLocks)
    {
      if (size % nrLocks != 0)
      {
        throw new Exception("The intital size % nrbuckets must be equal to zero");
      }
      _buckets = MakeBuckets(size);
      _locks = MakeLocks(nrLocks);
      _threshold = CalculateThreshold(size);
    }


    private Node[] MakeBuckets(int nrBuckets)
    {
      return new Node[nrBuckets]; ;
    }

    private object[] MakeLocks(int nrLocks)
    {
      var temp = new object[nrLocks];
      for (var i = 0; i < nrLocks; i++)
      {
        temp[i] = new object();
      }

      return temp;
    }

    #region Utility

    private int GetLockIndex(int hashCode)
    {
      return hashCode % _locks.Length;
    }

    private Node CreateNode(K key, V value)
    {
      return new Node(key, value);
    }

    private int GetBucketIndex(int hashCode)
    {
      return GetBucketIndex(_buckets.Length, hashCode);
    }

    private Node FindNode(Node node, K key)
    {
      while (node != null && !key.Equals(node.Key))
        node = node.Next;
      return node;
    }

    private void LockAll()
    {
      foreach (var lo in _locks)
      {
        Monitor.Enter(lo);
      }
    }

    private void UnlockAll()
    {
      foreach (var lo in _locks)
      {
        Monitor.Exit(lo);
      }
    }

    private void InsertInBucket(Node[] buckets, Node node, int index)
    {
      InsertInBucket(buckets, node, buckets[index], index);
    }

    private void InsertInBucket(Node node, int index)
    {
      InsertInBucket(node, _buckets[index], index);
    }

    private void InsertInBucket(Node node, Node curNode, int index)
    {
      InsertInBucket(_buckets, node, curNode, index);
    }

    private void InsertInBucket(Node[] buckets, Node node, Node curNode, int index)
    {
      if (curNode != null)
      {
        node.Next = curNode;
      }
      buckets[index] = node;
    }

    #endregion Utility

    public override int Count {
      get {
        lock (_sizeLock)
        {
          return _size;
        }
      }

    protected set {
        lock (_sizeLock)
        {
          _size = value;
        }
      } 
    }

    public override bool ContainsKey(K key)
    {
      var hashCode = GetHashCode(key);
      lock (_locks[GetLockIndex(hashCode)])
      {
        var bucket = _buckets[GetBucketIndex(hashCode)];
        return FindNode(bucket, key) != null;
      }
    }

    public override V Get(K key)
    {
      var hashCode = GetHashCode(key);
      lock (_locks[GetLockIndex(hashCode)])
      {
        var bucket = _buckets[GetBucketIndex(hashCode)];
        var node = FindNode(bucket, key);

        if (node == null)
        {
          //If node is null, key is not in map
          throw new KeyNotFoundException("Key not found. Key: "+key);
        }

        return node.Value;
      }
    }

    public override void Add(K key, V value)~\label{line:hashmap_lock_add}~
    {
      var hashCode = GetHashCode(key);
      lock (_locks[GetLockIndex(hashCode)])~\label{line:hashmap_lock_lockindex}~
      {
        var index = GetBucketIndex(hashCode);
        var bucket = _buckets[index];
        var node = FindNode(bucket, key);

        if (node != null)
        {
          //If node is not null, key exist in map. Update the value
          node.Value = value;
        }
        else
        {
          //Else insert the node
          InsertInBucket(CreateNode(key, value),bucket,index);
          lock (_sizeLock)
          {
            _size++;
          }
        }
      }

      ResizeIfNeeded();
    }
    
    public override bool AddIfAbsent(K key, V value)
    {
      var hashCode = GetHashCode(key);
      lock (_locks[GetLockIndex(hashCode)])
      {
        var index = GetBucketIndex(hashCode);
        var bucket = _buckets[index];
        var node = FindNode(bucket, key);

        if (node != null) return false;
        //If node is not in map insert new node
        InsertInBucket(CreateNode(key, value), bucket, index);
        lock (_sizeLock)
        {
          _size++;
        }
        ResizeIfNeeded();
        return true;
      }
    }

    public override bool Remove(K key)
    {
        var hashCode = GetHashCode(key);
        lock (_locks[GetLockIndex(hashCode)])
        {
          var index = GetBucketIndex(hashCode);
          var bucket = _buckets[index];
          return RemoveNode(key, bucket, index);
        }
    }

    private bool RemoveNode(K key, Node node, int index)
    {
        if (node == null)
        {
          return false;
        }
            
        if (node.Key.Equals(key))
        {
          lock (_sizeLock)
          {
            _size--;
          }
          buckets[index] = node.Next;
          return true;
        }


        while (node.Next != null && !key.Equals(node.Next.Key))
          node = node.Next;

        //node.Next == null || node.Next.Key == key
        if (node.Next == null) return false;

        lock (_sizeLock)
        {
          _size--;
        }
        node.Next = node.Next.Next;
        return true;
    }

    private void ResizeIfNeeded()~\label{line:hashmap_lock_resize}~
    {
      if (ResizeCondtion())~\label{line:hashmap_lock_resize_cond_before}~
      {
          LockAll();~\label{line:hashmap_lock_resize_lock}~
          try
          {
            if (!ResizeCondtion())~\label{line:hashmap_lock_resize_cond_after}~
            {
              return;
            }
            //Construct new backing array
            var newBucketSize = _buckets.Length * 2;
            var newBuckets = MakeBuckets(newBucketSize);

            //For each key in the map rehash
            for (var i = 0; i < _buckets.Length; i++)
            {
              var node = _buckets[i];
              while (node != null)
              {
                var bucketIndex = GetBucketIndex(newBucketSize, node.Key);
                InsertInBucket(newBuckets,CreateNode(node.Key,node.Value),bucketIndex);
                node = node.Next;
              }
            }

            //Calculate new resize threshold and assign the rehashed backing array
            threshold = CalculateThreshold(newBucketSize);
            _buckets = newBuckets;
          }
          finally
          {
            UnlockAll();
          }
      }
    }

    private bool ResizeCondtion()
    {
      lock (_sizeLock)
      {
        return _size >= _threshold;
      }
    }

    public override V this[K key]
    {
      get { return Get(key); }
      set { Add(key,value); }
    }

    public override IEnumerator<KeyValuePair<K, V>> GetEnumerator()
    {
      LockAll();
      try
      {
        var list = new List<KeyValuePair<K,V>>(_size);
        for (var i = 0; i < _buckets.Length; i++)
        {
          var node = _buckets[i];
          while (node != null)
          {
            list.Add(new KeyValuePair<K, V>(node.Key, node.Value));
            node = node.Next;
          }
        }

        return list.GetEnumerator();
      }
      finally
      {
        UnlockAll();
      }
    }

    private class Node
    {
      public K Key { get; private set; }
      public V Value { get; internal set; }
      public Node Next { get; internal set; }

      public Node(K key, V value)
      {
        Key = key;
        Value = value;
      }
    }
  }
\end{lstlisting}
\section{STM Library}\label{app:impl_stm_lib}
\section{\stmname}\label{app:impl_stm_lab}

