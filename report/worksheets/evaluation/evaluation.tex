\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Evaluation of Characteristics}{1}{Marts 2, 2015}{Andreas}{../../}
This chapter evaluates \stmname, its associated \ac{STM} library, and locking in C\# according to the evaluation method described in \bsref{sec:eval_approach}. The evaluation facilitates a conclusion on our hypothesis \textit{``Language integrated \ac{STM} provides a valid alternative to locking in terms of usability, and provides additional benefits compared to library-based \ac{STM}, when solving concurrent problems in C\#''} defined in \bsref{sec:problem_statement}.
\label{chap:evaluation}
The following sections describes how each of the three concurrency approaches are evaluated according to the characteristics. Each of the three concurrency approaches is given a placement on the spectrum of a given characteristic, as defined in \bsref{sec:eval_approach}.

\section{Implicit or Explicit Concurrency}
All the selected concurrency approaches rely on starting threads in order to introduce concurrency as well as manually specifying critical regions using either locks or the \bscode{atomic} block. This makes all the approaches lean toward the explicit end of the spectrum. The two \ac{STM} based approaches are however more implicit as \ac{STM} abstracts away synchronization details. Locking in C\# on the other hand requires explicitly stating how synchronization is achieved and is therefore placed close to the explicit concurrency extreme. \stmnamesp and the \ac{STM} library reside slightly more towards the implicit concurrency end of the spectrum. The placement of the three concurrency approaches on the implicit - explicit concurrency spectrum is depicted in \bsref{fig:char_implicit_explicit}.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_implicit_explicit}
\caption{Concurrency approaches on the implicit - explicit concurrency spectrum}
\label{fig:char_implicit_explicit}
\end{figure}

\section{Fault Restrictive or Expressive}
Locking presents the programmer with a set of constructs aimed at solving concurrency problems, but does little to guarantee correct usage. The locking constructs in C\# are explained in detail in \bsref{sec:locking}. Locking enables control of synchronization at a very low level of detail, which is very expressive. Therefore, locking in C\# is placed at the expressive end of the spectrum.

The \ac{STM} based approaches delegate the details of how synchronization is achieved to the underlying \ac{STM} system, allowing \ac{STM} based concurrency to avoid some of the errors associated with locking, such as deadlocks. The \ac{STM} based approaches however still rely on shared memory for communication and require programmers to define transaction scopes and introduce concurrency by starting threads. The abstractions provided by \ac{STM} limits the possibility of expressing synchronization at a low level of  detail. The \ac{STM} based approaches reside towards the expressive end of the spectrum but contain fault restrictive elements pulling them more towards the fault restrictive extreme than locking. \stmname however implements a number of compile time errors and warnings keeping the programmer from utilizing undesirable combinations such as \bscode{retry} statements outside \bscode{atomic} or \bscode{orelse} block, moving it slightly towards the fault-restrictive end of the spectrum. The placement of the three concurrency approaches on the fault restrictive - expressive spectrum is depicted in \bsref{fig:char_fault_expressive}.
\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_fault_expressive}
\caption{Concurrency approaches on the fault restrictive - expressive spectrum}
\label{fig:char_fault_expressive}
\end{figure}

\section{Pessimistic or Optimistic}
Locking applies synchronization by enforcing mutual exclusion. This approach is well suited in scenarios where errors are common which would result in a high number of aborts if an \ac{STM} based approach had been used. Locking is therefore an inherently pessimistic concurrency approach as it prevents errors from occurring instead of correcting them when they occur. \ac{STM} on the other hand allows multiple threads to proceed simultaneously, correcting any errors that may occur by aborting and re-executing transactions. Hence \ac{STM} takes an optimistic approach to concurrency. However, the employed \ac{STM} system uses lazy updates as opposed to eager updates, which is a slightly more pessimistic approach to \ac{STM} keeping \stmnamesp and the \ac{STM} library from reaching the optimistic extreme.Therefore \stmnamesp and the \ac{STM} library resides close to at the optimistic extreme of the pessimistic - optimistic spectrum while locking resides close to at the pessimistic extreme. The placement of the three concurrency approaches on the pessimistic - optimistic spectrum is depicted in \bsref{fig:char_pes_opti}.
\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_pessimistic_optemistic}
\caption{Concurrency approaches on the pessimistic - optimistic spectrum}
\label{fig:char_pes_opti}
\end{figure}

\section{Readability \& Writability}\label{subsec:tl_charac_read_and_write}
The evaluation of readability and writability is based on a number of shared characteristics: Data Types, Syntax Design, Simplicity, and Orthogonality. The characteristics Data Types and Syntax Design will not be evaluated on a spectrum of two extremes, as the choices made are trade-offs affecting other characteristics, e.g. simplicity and readability. The evaluation of these will therefore be taken into account when the other characteristics are evaluated.

In addition to the shared characteristics, writability is based on level of abstraction and expressivity.
%that of simplicity and orthogonality as well as a number of other considerations. Simplicity and orthogonality is described in the following sections followed by a final evaluation of readability.
\subsection{Data Types}\label{subsec:datatypes}
All three concurrency approaches are either integrated into or build around C\#, which means they have almost the same data types. A difference lies in the \ac{STM} approaches where the types of transactional variables are treated differently. In the \ac{STM} library, transactional variables are defined using transactional types, such as \bscode{TMInt}, which means that it is possible to create an array or list containing these types, e.g. \bscode{TMInt[]} defines an array of \bscode{TMInt} types. \stmname instead  preserves the original types of transactional variables, allowing the programmer to utilize an \bscode{atomic} variable of type $T$ as if it was of type $T$ even though the compiler transforms the type of the variable to $T$'s corresponding \ac{STM} type, as described in \bsref{subsec:extension_field}. As transactional variables are not special types in \stmname it is not possible to define a list or array of transactional variables directly, instead a wrapper class with an \bscode{atomic} field must be employed.

The need to define an array of transactional types was experienced during the development of the hashmap implementations which use an array to represent the buckets of the hashmap. \bsref{lst:lib_Buckets} and \bsref{lst:lang_Buckets} show how the hashmap buckets are defined in the \ac{STM} library and \stmname, respectively. In the library \ac{STM} example on line \ref{line:lib_bucket} the buckets are defined directly. The type of the \bscode{\_buckets} field will be explained gradually. The inner \bscode{Node} type, is a simple class which represents a key value pair, where the value is a transactional variable, defined in the \ac{STM} library code on line \ref{line:lib_node_c} and in \stmname code on line \ref{line:lang_node_c}. In case of collisions the \bscode{Node} class allows for chaining of nodes representing the key/value pairs inserted into the hashmap through its \bscode{Next} property. Each bucket is represented by a transactional variable which points to the first element in the collision list, if any such element exists. The \bscode{Next} property of the \bscode{Node} class is transactional, allowing the system to detect changes to the internals of the collision list. This, along with the transactional variable pointing to the first element in the list, allows for changes to the entire collision list to be tracked. Finally the backing array is also wrapped in a transactional variable allowing the \ac{STM} system to track assignments to the entire backing array in order track when the backing array is resized. In the \stmname example on line \ref{line:lang_bucket} it is not possible to define the array of transactional variables directly, so a wrapper type called \bscode{Bucket} defined on line \ref{line:lang_bucket_class} is used. This is a consequence of the design of the \stmname.

\begin{lstlisting}[float,label=lst:lib_Buckets,
  caption={HashMap Buckets Array - \ac{STM} Library},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out, readonly}]  % Start your code-block
  
  public class StmHashMap<K,V> : BaseHashMap<K,V>
  {
    private readonly TMVar<TMVar<Node>[]> _buckets =~\label{line:lib_bucket}~
    new TMVar<TMVar<Node>[]>();
  
    ...  //Other code
  
    private class Node~\label{line:lib_node_c}~
    {
      public K Key { get; private set; }
      public TMVar<V> Value { get; private set; }
      public TMVar<Node> Next { get; private set; }
      public Node(K key, V value)
      {
        Key = key;
        Value = new TMVar<V>(value);
        Next = new TMVar<Node>();
      }
    }
  }
\end{lstlisting}

\begin{lstlisting}[float,label=lst:lang_Buckets,
  caption={HashMap Buckets Array - \stmname},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out}]  % Start your code-block
  
  public class StmHashMap<K,V> : BaseHashMap<K,V>
  {
    private atomic Bucket[] _buckets;~\label{line:lang_bucket}~
  
    ... //Other code
    
    private class Bucket~\label{line:lang_bucket_class}~
    {
      public atomic Node Value { get; set; }
    }
  
    private class Node ~\label{line:lang_node_c}~
    {
      public K Key { get; private set; }
      public atomic V Value { get; set; }
      public atomic Node Next { get; set; }
      public Node(K key, V value)
      {
        Key = key;
        Value = value;
      }
    }
  }
\end{lstlisting}

Ultimately prohibiting the programmer to define an array or list of transactional types directly, lowers the readability and writability of \stmname, as it requires the programmer to write, read and maintain an extra wrapper class. To remedy this, a library of data structures which provides tracking to internal changes could be included in the language.

The special types used by the \ac{STM} library to represent transactional variables requires the programmer to use the \bscode{Value} property whenever she needs to make an assignment. Implicit conversion ensures that an object of one of the \ac{STM} types, such as \bscode{TMInt}, in most cases can be used as an object of the type it is wrapping. \bsref{lst:lib_implicit_conversion} shows an equality comparison of two transactional variables using the \ac{STM} library. The comparison on line \ref{line:lib_equality} requires the programmer to access the \bscode{Value} property of the \bscode{TMVar} objects as implicit conversion will not be used if the \bscode{TMVar}'s are compared directly. If the value property had not been used the \bscode{TMVar} objects would have been compared, producing an incorrect result. A similar problem exists when calling a method on a \bscode{TMVar} object, implicit conversion does not allow methods of the wrapped type to be called on the \bscode{TMVar} directly.

\begin{lstlisting}[float, label=lst:lib_implicit_conversion,
  caption={Equality comparison of \bscode{TMVar<bool>}},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out, bool}]  % Start your code-block

  public bool TestMethod()
  {
    TMVar<bool> v1 = new TMVar<bool>(false);
    TMVar<bool> v2 = new TMVar<bool>(false);
    return v1.Value == v2.Value;~\label{line:lib_equality}~
  }
\end{lstlisting}

The two \ac{STM} based approaches have problems combining with existing data structures. For example, if a programmer utilizes a \bscode{List<T>} inside a transaction, any operations on the list are not tracked by the \ac{STM} system as \bscode{List<T>} is not implemented using transactional variables. Therefore operations on the list take effect immediately. A transaction may be executed multiple times due to being aborted and retried, resulting in the operations, such as adding an element to the list, being executed and taking effect multiple times. Consequently data structures utilized in transactions must be: \begin{inparaenum}[\itshape a\upshape)]
 \item Implemented using transactional variables, allowing the \ac{STM} system to track any changes, or
 \item Immutable and tracked through assignment to a transactional variable.
\end{inparaenum} 

%Extra der påvirker data types:
	%Måske nævn det har samme behaviour som virtual modifieren (var det ikke det du sagde kasper?)
	%Måske noget om at ac# fungerer også med ref og out (som library ikke kan), så det har en bedre integartion med datatyperne i sporget?? (men det er jo keywords det integreres med, så måske en anden formulering)
	%Andreas skrevet: Using STM types could imply a different meaning and confusing the programmer. Is TMInt the same value as int?
\subsection{Syntax Design}\label{subsec:syntaxdesign}
The use of keywords reduce simplicity but increase readability, as the intent stands out clearly\cite[p. 12-13]{sebestaProLang}. Locking in C\# employs only a single keyword, \bscode{lock}. The rest of the functionality is provided by library calls as described in \bsref{sec:locking}. The use of libraries for locking constructs makes it blend in with other library code, even though it has a special purpose related to synchronization. This decreases the readability, but keeps the simplicity of the language as it does not introduce keywords for all constructs.

The \ac{STM} library also uses library calls as described above, thus it has the same disadvantages and the readability is decreased compared to \stmname which has keywords for the special constructs. The four keywords introduced in \stmname do however decrease the simplicity of the language. As the \bscode{atomic} keyword has different meanings depending on the context in \stmname, its readability is reduced. The simplicity is however raised by employing a minimum of keywords.

The \ac{STM} library requires the programmer to use static method calls, wrap transactional code in lambdas, wrap transactional variables in \bscode{TMVars}, use the \bscode{Value} property when getting or setting a value, supply \bscode{orelse} transactions as arguments to the atomic method call, and write return in front of the static method call if a method must return the value computed by a transaction. All of these concerns are abstracted away in \stmname.

In C\# it is possible to name variables after reserved keywords, by prefixing the name with \bscode{@}. Due to this, the impact of the additional keywords in \stmname on the naming of variables is reduced and it is distinguishable when \bscode{atomic} is used as a name or a keyword.

\subsection{Low or High Simplicity}\label{subsec:simplicity}
Locking is based on the idea of mutual exclusion. C\# supplies a number of different constructs for defining synchronization using locking as described in \bsref{sec:locking}. Applying locking correctly in complex scenarios is considered to be hard\cite[p. 56]{sutter2005software}, mainly due to the number of errors that can arise, such as deadlocks.

Locking requires the programmer to explicitly state how synchronization is to be applied. Both library-based \ac{STM} and \stmname take a more declarative approach than locking when specifying synchronization, thus it is simpler as the programmer does not have to worry about low level details. The usability studies produced by Rossbach et al. in \cite{rossbach2010transactional} and Pankratius et al. in \cite{pankratius2009does} find that the surveyed students found \ac{STM} simpler than fine grained locking but more complex than coarse grained locking due to issues understanding the execution of transactions. 

In case of conditional synchronization, both forms of \ac{STM} can leverage the \bscode{retry} functionality, making a transaction block until the variables previously read by the transaction are changed. In C\# a \bscode{Monitor} allows blocking until another thread notifies the blocked thread, but contrary to \bscode{retry} this is not on a declarative level. The \bscode{retry} statement was used in the two \ac{STM} based queue implementations to, with only two lines of code, make the calling thread block until the queue is non-empty in case \bscode{Dequeue} is called on an empty queue. The same feature in the lock-based implementation would require the use of a semaphore or the \bscode{Monitor} class's \bscode{Wait} and \bscode{Pulse/PulseAll} methods, which both require the programmer to manage low level details.

\bsref{lst:lock_add_hashmap} and \bsref{lst:lang_add_hashmap} show the \bscode{Add} method for the locking and library-based \ac{STM} hashmap implementations respectively. 
The locking hashmap implementation divides the backing array into a number of stripes, where each stripe is protected by its own lock. When accessing a bucket the hashmap must determine what lock to acquire based on the index of the bucket. This strategy is further described in \bsbilagref{app:lock_hashmap_description}. In \bsref{lst:lock_add_hashmap} on line \ref{line:lock_lock_bucket}, a calculation is made to determine which lock needs to be used, additionally on line \ref{line:lock_lock_size} another lock is needed for synchronizing access to the \bscode{\_size} variable as the previously acquired lock only covers part of the buckets, meaning that another thread could be changing the \bscode{\_size} variable. This is avoided in \bsref{lst:lang_add_hashmap} where the method is wrapped in an \bscode{atomic} block, and the \ac{STM} system detects and resolves potential conflicts.

Library-based \ac{STM} does not have support for checking implicit dependency between static calls at compile time, e.g. a \bscode{retry} outside an \bscode{atomic} call will not produce a compile time error. Additionally, the \ac{STM} types provided must be used to track variables in transactions. These types cause a type mismatch when used together with standard types, thus making the library more complex to use. This issue is partly resolved by providing implicit type conversion on the \ac{STM} types, but the implicit conversion is not possible in all cases. In the cases where it is not, the programmer must access the wrapped value by the \bscode{Value} property available on all \ac{STM} types.

\stmnamesp introduces additional language constructs which reduces the simplicity of the language. It does however increase the simplicity of using the \ac{STM} part, e.g. using \bscode{retry} outside of an \bscode{atomic} block will result in a compile time error. Additionally, \bscode{atomic} can also be used along with fields, local variables, and parameters, making them traceable in transactions without having to use specific \ac{STM} types. This simplifies interaction between code that uses \bscode{atomic} variables and code that does not.

\begin{lstlisting}[label=lst:lock_add_hashmap,
  caption={ConcurrentHashMap \bscode{Add} Method - Locking},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out}]  % Start your code-block

  public override void Add(K key, V value)
  {
      var hashCode = GetHashCode(key);
      lock (_locks[GetLockIndex(hashCode)])~\label{line:lock_lock_bucket}~
      {
          var bucket = _buckets[GetBucketIndex(hashCode)];
          var node = FindNode(bucket, key);

          if (node != null)
          {
              //If node is not null, key exist in map. Update the value
              node.Value = value;
          }
          else
          {
              //Else insert the node
              bucket.AddFirst(CreateNode(key, value));
              lock (_sizeLock)~\label{line:lock_lock_size}~
              {
                  _size++;
              }
          }
      }
      
      ResizeIfNeeded();
  }
\end{lstlisting}

\begin{lstlisting}[label=lst:lang_add_hashmap,
  caption={ConcurrentHashMap \bscode{Add} Method - \stmname},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out}]  % Start your code-block
  
  public override void Add(K key, V value)
  {
      atomic
      {
          var bucketIndex = GetBucketIndex(key);
          //TMVar wrapping the immutable chain list
          var bucketVar = _buckets[bucketIndex];
          var node = FindNode(key, bucketVar.Value);
         
          if (node != null)
          {
              //If node is not null key exist in map. Update the value
              node.Value = value;
          }
          else
          {
              //Else insert the node
              bucketVar.Value = bucketVar.Value.Add(CreateNode(key, value));
              _size++;
              ResizeIfNeeded();
          }
      }
  }
\end{lstlisting}

The placement of the three concurrency approaches on the low simplicity - high simplicity spectrum is depicted in \bsref{fig:char_simplicity}.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_read_simplicity}
\caption{Concurrency approaches on the low - high simplicity spectrum}
\label{fig:char_simplicity}
\end{figure}
% Additional constructs: Atomic block, orelse, retry, atomic fields
% In language atomic is a modifier, not a type (atomic int can be passed into an int param)	. The .value can be skipped.
% Conditional syncronization is very easy in STM
% Waiting on a certain key on a hashmap is hard to implement with locks, but easy with STM.
% Concurrency related issues are fewer in STM
\subsection{Low or High Orthogonality}\label{subsec:orthogonality}
As described in \bsref{sec:locking}, locking encompasses a number of basic constructs aiding in different concurrency scenarios. These constructs can be combined to handle complex concurrency issues. Some of these combinations are however erroneous, producing hard to debug problems such as deadlocks. Locking does not put any restraints on the language features with which it can be combined and may therefore seem to be highly orthogonal. The risk of deadlocks when combining lock-based implementations or employing multiple locks limit the orthogonality, keeping locking from reaching the high orthogonality extreme. Locking in C\# provides no solutions to these issues. As a result locking in C\# is placed between the middle and the high orthogonality extreme.

\ac{STM} removes the issue of deadlocks and allows \ac{STM} based code segments to be combined using transactional nesting. \ac{STM} combines poorly with irreversible actions, that is actions which cannot be rolled back in case a transaction aborts such as \ac{IO}. Neither the \ac{STM} library nor \stmnamesp offers a solution to this problem significantly reducing their orthogonality. Furthermore both the \ac{STM} library and \stmnamesp have problems combining with existing data structures reducing their orthogonality further.

As described in \bsref{subsec:datatypes} the programmer cannot rely on implicit conversion from an \ac{STM} object to the value it wraps in all cases, reducing the orthogonality of the \ac{STM} library. The \ac{STM} library however benefits from the advantages provided by \ac{STM}, but is hampered by the not being able to combine with irreversible actions and existing data structures. Consequently library-based \ac{STM} is placed just above the middle on the low - high orthogonality spectrum. \stmnamesp treats transactional variables as an object of their original type, removing the type mismatch between the regular types and the corresponding \ac{STM} types. As a result, \stmname allows transactional variables to be compared directly and methods can be invoked directly on the transactional variable, without having to reason about implicit conversion or manually accessing the \bscode{Value} property, as described in \bsref{subsec:datatypes}. Therefore \stmname is placed further towards the high orthogonality end of the spectrum than library-based \ac{STM}. \stmname however remain more towards the low orthogonality extreme than locking.

The placement of the three concurrency approaches on the low - high orthogonality spectrum is depicted in \bsref{fig:char_orthogonality}.


%orthogonality
%locking deadlocks
%types in language
%++ -- operators
%STM, IO
\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_orthogonality}
\caption{concurrency approaches on the low - high orthogonality spectrum}
\label{fig:char_orthogonality}
\end{figure}

\subsection{Low or High Readability}\label{subsec:char_readability}
As described in \bsref{subsec:syntaxdesign}, locking in C\#, except the lock statement, is provided by library calls, and library \ac{STM} is only provided by library calls. This negatively affect their readability because these calls blends in with other library code. To avoid this confusion \stmname uses special keywords which positively affects its readability, however it also negatively affects simplicity and thereby the readability because the programmer has to know these keyword. Also the \bscode{atomic} keyword has different meanings depending on the context. This negatively affects the readability, as the programmer must be aware of these different meanings. Much of the boilerplate code necessary in the \ac{STM} library is abstracted away in \stmname, e.g. use of the Value property, which improves its readability as there is less code to reason about.

In \bsref{subsec:datatypes} the data types characteristic is described. The \ac{STM} library treats transactional variables as special types, where \stmname treats transactional variables as regular types with an associated atomic keyword modifier. As a result it is not possible to define an array or list of transactional types directly in \stmname, which reduces its readability, because of the extra boilerplate code that the required wrapper class introduces. Additionally the \ac{STM} library allows for implicit conversion when reading a transactional value, thereby avoiding the specification of the Value property, which positively affects the readability. Implicit conversion can however produce incorrect results and is not applicable in all scenarios, so ultimately the readability suffers.

In \bsref{subsec:simplicity} the simplicity of locking is placed close to the low simplicity extreme, where the \ac{STM} library is placed a bit higher than the middle of the spectrum and \stmname even higher. In \bsref{subsec:orthogonality} the orthogonality of locking resides between the middle and high end of the spectrum, while library-based \ac{STM} is placed just above the middle of the spectrum with \stmname just above it. These characteristics directly influence the readability of the concurrency approaches.

All the concurrency approaches have to explicitly mark critical regions of code in order to ensure a program is race condition free. This negatively affects their readability, as by reading the program it is hard to know whether critical regions are marked correctly everywhere, and it is especially hard in large programs.

The basic \bscode{lock} construct and idea behind locking is simple, if a resource is locked, only a single thread is allowed access to the resource. This positively affects the readability of locking and in small code segments it may seem highly readable. However locking suffers in particular from the concurrency issue of deadlocks. This negatively affects the readability of locking drastically, as in order to reason about deadlocks, the programmer has to reason about every code segment where locking is applied and how these segments interact. As locking code can be fragmented it can become hard for the programmer to reason about. Additionally, if a program makes use of other libraries that uses locking internally, the programmer also have to reason about the locks contained within those libraries, as locks do not compose. The readability of locking is therefore placed towards low readability on the spectrum.

The \ac{STM} approaches remove the issue of deadlocks, which positively affects the readability, as the programmer does not have to reason about deadlocks. Additionally, \ac{STM} also removes the issue of composing synchronized code segments, as \ac{STM} allows nested transactions. Similar to locking, \ac{STM} suffers from code fragmentation which can make it hard to get an overview of all the \ac{STM} synchronization in a program, which affects the readability negatively. Furthermore understanding the concept of memory transactions can, as described in \cite{rossbach2010transactional}, at first be hard to grasp, as it promotes a new way of synchronizing programs. This problem is worsened since both the \bscode{orelse} and \bscode{retry} constructs have been included in the \ac{STM} library and \stmname. Additionally, \stmname is able to produce compile time errors and warnings, e.g. when a \bscode{retry} keyword is defined outside an \bscode{atomic} scope, which improves its readability over the \ac{STM} library, which does not have this capability. Library \ac{STM} have a type mismatch between \ac{STM} types and regular types, which \stmname does not. Therefore \stmname has higher readability than the \ac{STM} library.

Ultimately the \ac{STM} library is placed close to the middle on the spectrum and \stmname further towards the high readability extreme. The main drawback for both approaches, is that the programmer has to mark critical regions of code which can be very fragmented. Additionally understanding the concept of memory transactions may at first be hard, especially as both the \bscode{orelse} and \bscode{retry} constructs have been introduced.

The placement of the three concurrency approaches on the low readability - high readability spectrum is shown in \bsref{fig:char_readability}.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_readability}
\caption{Concurrency approaches on the low - high readability spectrum}
\label{fig:char_readability}
\end{figure}

\subsection{Low or High Level of Abstraction}\label{subsec:level_of_abstraction}
Locking is tightly coupled with the hardware architecture through hardware instructions such as Test-and-set and Compare-and-swap\cite[p. 1990]{scott2011sync}. Furthermore the low-level abstraction of threads isused in order to introduce concurrency. Additionally the programmer has to state exactly how synchronization should be applied using locks. C\# offers the \bscode{lock} statement which provides a small abstraction over the release of a lock. The \bscode{lock} statement is however not applicable in all cases. If for example a timeout on the acquisition of a lock is required or a more advanced form of lock, such as a semaphore, is required, the \bscode{lock} keyword is not applicable. That is the case in the locking Dining Philosophers implementation, which requires the second lock to be taken with a timeout. Furthermore the locking Santa Claus implementation uses semaphores to signal between Santa, the elfs and the reindeer. The \bscode{lock} keyword does not provide such capabilities. Additionally correct usage of the \bscode{Monitor} class leads to the use of a \bscode{try/finally} block to ensure that the acquired lock is released in case of an exception\cite{msdnMonitorEnter}, reducing the level of abstraction. Ultimately locking in C\# is placed close to the low level of abstraction extreme of the spectrum with the small abstractions provided keeping it from being at the extreme.

The \ac{STM} approaches also rely on threads, but provide a higher level of abstraction for synchronization. \ac{STM} uses transactions, where code segments are marked and the details of how synchronization is achieved are abstracted away by the \ac{STM} system. Both \stmname and the \ac{STM} library facilities strong atomicity, as described in \bsref{sec:design_strong_weak_atomicity} and the \ac{STM} system will therefore manage both transactional and non-transactional access, thus keeping the level of abstraction high. Based on the above, the general \ac{STM} approach lies between the middle and high end of the spectrum, where the main drawbacks is that the programmer still has to manage threads and mark regions of code that should be synchronized.

Some differences in the level of abstraction exist with regards to \stmname and the \ac{STM} library. As described in \bsref{subsec:syntaxdesign} the \ac{STM} library requires the programmer to use static method calls and lambdas for defining transactions. \stmname substitutes this with language based support for the \bscode{atomic} block. \bsref{lst:lib_SleepUntilAwoken} and \bsref{lst:lang_SleepUntilAwoken} present an implementation of the \bscode{SleepUntilAwoken} method from the library and \stmname Santa Claus problem implementations, respectively. The method ensures that Santa sleeps until he is awoken by either three elfs at his door, or all reindeers back from vacation, ready to fly his sleigh. The \bscode{return} statement on line \ref{line:lib_sleep_return} of \bsref{lst:lib_SleepUntilAwoken} is not present in the \stmname implementation as it is abstracted away by \stmname. Furthermore the static method call and creation of lambas to represent transaction bodies on line \ref{line:lib_sleep_return} is abstracted away by the \bscode{atomic} block and orelse block on lines \ref{line:lang_sleep_atomic} and \ref{line:lang_sleep_orelse} of \bsref{lst:lang_SleepUntilAwoken}.

\begin{lstlisting}[label=lst:lib_SleepUntilAwoken,
  caption={\bscode{SleepUntilAwoken} Method - \ac{STM} Library},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out}]  % Start your code-block

  private WakeState SleepUntilAwoken()
  {
    return STMSystem.Atomic(() =>~\label{line:lib_sleep_return}~
    {
      if (_rBuffer.Count != SCStats.NR_REINDEER)
      {
        STMSystem.Retry();
      }
      return WakeState.ReindeerBack;
    },
      () =>~\label{line:lib_t2_def}~
      {
        if (_eBuffer.Count != SCStats.MAX_ELFS)
        {
          STMSystem.Retry();
        }
        return WakeState.ElfsIncompetent;
      });
  }
\end{lstlisting}

\begin{lstlisting}[label=lst:lang_SleepUntilAwoken,
  caption={\bscode{SleepUntilAwoken} Method - \ac{STM} Language},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out}]  % Start your code-block

  private WakeState SleepUntilAwoken()
  {
    atomic~\label{line:lang_sleep_atomic}~
    {
      if (_rBuffer.Count != SantaClausProblem.NR_REINDEER)
      {
        retry;
      }
      return WakeState.ReindeerBack;
    }
    orelse~\label{line:lang_sleep_orelse}~
    {
      if (_eBuffer.Count != SantaClausProblem.MAX_ELFS)
      {
        retry;
      }
      return WakeState.ElfsIncompetent;
    }
  }
\end{lstlisting}
The \ac{STM} library exposes transactional variables as special \ac{STM} types, where  \stmnamesp instead allows variables to be marked as \bscode{atomic}, letting the programmer preserve the original type. \stmnamesp is therefore considered to have a higher level of abstraction than library \ac{STM}. As described previously \ac{STM} however combines poorly with irreversible actions leaving it up to the programmer to correctly handle actions such as \ac{IO} in combination with transactions. As neither the \ac{STM} library nor \stmnamesp can abstract over these problem, their level of abstraction is reduced. Therefore library-based \ac{STM} is placed just above the middle of the spectrum while \stmname resides further towards the high level of abstraction extreme.

The placement of the three concurrency approaches on the low level of abstraction - high level of abstraction spectrum is depicted in \bsref{fig:char_level_of_abstraction}.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_level_of_abstraction}
\caption{Concurrency approaches on the low - high level of abstraction spectrum}
\label{fig:char_level_of_abstraction}
\end{figure}

\subsection{Low or High Expressivity}\label{subsec:expressivity}
%The expressivity of the approaches are closely related to their level of abstraction.
The locking constructs in C\# present different ways to express exactly how synchronization should be applied, thereby affecting the expressivity positively. Since locking is prone to a number of concurrency related issues, the expressivity is severely reduced as the programmers focus is limited by the complex synchronization form. Locking in C\# gives the programmer control over many low level details concerning how synchronization is applied but at the same time requires the programmer to specify these details. This along with the risk of deadlocks and other issues limits how the programmer can express functionality concisely and conveniently. Locking is therefore placed towards low expressivity, being drawn a bit towards the middle of the spectrum because of the many choices in locking constructs C\# offers.

\ac{STM} also builds upon threads which limits its expressivity. Memory transactions however represent a more declarative and expressive approach than locking, as the programmer only has to specify critical regions, allowing the \ac{STM} system to manage the details of how synchronization is applied. This affects the expressivity positively, as it accomplishes a great deal of computation with little code. Furthermore \ac{STM} eliminates the issues of deadlocks which makes it more convenient to express synchronization, as the programmer does not have to reason about it. However, neither in the \ac{STM} library nor \stmname a convenient way to express irreversible actions exists, such as exceptions and \ac{IO}, the programmer is left alone in ensuring these actions work correctly with transactions, which negativity affects the expressivity. Furthermore, having to rely solely on transactional or immutable data structures limits the expressivity of the \ac{STM} based approaches. Based on the above, the general \ac{STM} approach lies between the middle and high end of the spectrum.

Some differences with regards to expressivity between library-based \ac{STM} and \stmname exist. The expressivity of the approaches is closely related to their level of abstraction, described in \bsref{subsec:level_of_abstraction}. As described in \bsref{subsec:syntaxdesign}, library \ac{STM} requires the programmer to put extra effort into expressing the intended functionality e.g. wrapping transactional code in lambdas, wrapping transactional variables in \bscode{TMVar} types and using the \bscode{Value} property when getting or setting a value on a transactional variable. That is abstracted away in \stmname which makes it more expressive as it provides a more convenient and less tedious way of specifying computations. However, the abstraction that \stmname provides, disallows the programmer from defining an array of transactional types directly and instead requires the programmer to use a wrapper class, as described in \bsref{subsec:datatypes}. Based on the above, \stmname is considered to have a higher expressivity than library \ac{STM} because of the higher level of abstraction that it facilitates. The difference is however limited as \stmname does not allow for the definition of an array or list of transactional types as described above.

The placement of the three concurrency approaches on the low expressivity - high expressivity spectrum is depicted in \bsref{fig:char_expressivity}.

%expressivity:
%great deal of computation accomplished with a small program
	%fx. retry
%convenient ways of specifying computations
\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_expressivity}
\caption{Concurrency approaches on the low - high expressivity spectrum}
\label{fig:char_expressivity}
\end{figure}

\subsection{Low or High Writability}
As discussed in \bsref{subsec:level_of_abstraction} locking in C\# has a low level of abstraction due to its usage of low level constructs. The \bscode{lock} statement provides an abstraction over the acquisition and release of a lock, providing increased writability in cases where it is applicable. The writability of locking in C\# is however reduced as a result of the low level of abstraction. The \ac{STM} library's level of abstraction is placed just above the middle towards the high level of abstraction end of the spectrum, while \stmname has a higher level of abstraction than the \ac{STM} library. This positively impacts the writability of the \ac{STM} library and \stmname.

The locking constructs described in \bsref{sec:locking} are prone to common locking problems, such as deadlocks, resulting in a low simplicity score which negatively impacts its writability. The expressivity of the \ac{STM} library resides above the middle of the spectrum, reduced by the need to wrap transactional code in lambdas, wrap transactional variables in \bscode{TMVar} types and use the \bscode{Value} property when getting or setting a value on a transactional variable, hindering the programmer from concisely expressing the intended behavior, resulting in reduced writability. \stmname removes this burden from the programmer, by delegating the work to the compiler, resulting in a higher expressivity score and improved writability.

With respect to simplicity, locking in C\# is, as described in \bsref{subsec:simplicity}, placed close to the low simplicity end of the spectrum mainly due the number of errors that can arise. This negatively impacts the approach's writability. The two \ac{STM} based approaches benefit from a declarative approach to defining synchronization. The \ac{STM} library is placed just above the middle of the spectrum, while \stmname is placed towards the high simplicity end of the spectrum. \stmname is given a higher simplicity score due to its cleaner syntax and the ability to use existing types instead of the \ac{STM} equivalents, resulting in a greater positive impact on writability.

As described in \bsref{subsec:orthogonality} locking in C\# has orthogonal properties but it is limited due to the risk of errors when combining locking constructs. The \ac{STM} based approaches benefit from simplified composition based on transactional nesting but simultaneously introduces issues with irreversible actions such as \ac{IO} as well as existing data structures. The \ac{STM} library has problems combining with existing types in all cases. Furthermore the implicit conversion feature cannot be relied on in all cases, requiring the programmer to access the \bscode{Value} property, reducing the orthogonality of the \ac{STM} library. Ultimately this results in the \ac{STM} library being placed just above the middle on the low - high orthogonality spectrum. \stmname addresses many of the issues present in the \bscode{STM} library  by allowing the programmer to use any existing types instead of the \ac{STM} types and by delegating much of the work required by the \ac{STM} library to the compiler. This results in \stmname being placed just above the \ac{STM} library on the  low - high orthogonality spectrum. Locking is however placed further towards the high orthogonality extreme due to its ability to correctly combine with most language constructs, excluding locking itself.  

Locking suffers from the risk of a number of serious errors, resulting in it being hard to use in complex scenarios, limiting its writability. The \ac{STM} based approaches solve many of the errors present with locking but introduces new problems with irreversible actions and data structures. The \ac{STM} library has problems with types, accessing the wrapped value, and the syntax of transaction definitions, which limits its writability. \stmname addresses many of the writability problems present in the \ac{STM} library by delegating the work to the compiler. Both \ac{STM} based approaches however require that data types, including collections, are constructed using transactional variables or implemented as immutable in order to interact with the \ac{STM} system, reducing their writability. Based on these observations and the evaluations of the previous characteristics, the three approaches have been placed on the low - high writability spectrum as depicted in \bsref{fig:char_tl_writability}.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{\rootpath/worksheets/evaluation/figures/char_writability}
\caption{Concurrency approaches on the low - high writability spectrum}
\label{fig:char_tl_writability}
\end{figure}
\worksheetend