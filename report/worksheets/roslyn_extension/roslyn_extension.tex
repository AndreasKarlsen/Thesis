\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Roslyn Extension}{0}{Februar 10, 2015}{}{../../}
The chapter describes how the Roslyn C\# compiler was extended to support the constructs of \stmname described in \bsref{chap:stm_design}. \bsref{sec:roslyn_extension_strategy} describes the overall strategy, \bsref{sec:roslyn_lexer_parser_changes} describes the changes made to the lexer and parser while \bsref{sec:syntax_tree_transformations} presents examples of the transformations made on the syntax tree by the extension.
\label{chap:roslyn_extension}
\section{Extension Strategy}
\label{sec:roslyn_extension_strategy}
The Roslyn C\# compiler was extended by modifying the lexing and parsing phases with support for the language construct described in \bsref{chap:stm_design}. The extended parsing phase outputs an extended syntax tree containing direct representations of the language changes provided by \stmname. The syntax tree is then analyzed by identifying \stmnamesp constructs, followed by a transformation where any language extension is transformed into equivalent C\# code utilizing the \ac{STM} library described in \bsref{chap:implementation}. 

The transformation phase outputs a syntax tree containing only standard C\# code, executing the described \ac{STM} operations. This syntax tree is then passed to the remaining C\# compiler phases, utilizing its semantic analysis and code generation implementations. The approach is visualized in \bsref{fig:compiler_pipeline_extension}. The parser has been extended to output an extended syntax tree and transformation of this tree occurs before the binding and IL emission phases. The transformation phase utilizes both the extended syntax tree and symbol information gather through the Roslyn \ac{API}.
\begin{figure}[htbp]
\centering
 \includegraphics[width=1\textwidth]{\rootpath/worksheets/roslyn_extension/figures/compiler_pipeline_extension} 
 \caption{Extension occurs at the syntax tree and symbol level.}
\label{fig:compiler_pipeline_extension}
\end{figure}

The described approach was selected due to the following reasons:
\begin{enumerate}
\item As described in \bsref{subsec:roslyn_first_phase} the C\# lexer  uses a simple \bscode{switch} case to identify tokens by choosing the type of token to identify based on the first character of the token, while the parser uses a recursive descent technique, both of which are implemented by hand. Such techniques have a low degree of complexity compared to strategies such as \ac{LALR}. As such modifying the lexer and parser is simpler than would be the case if more complex techniques had been employed.
\item The Roslyn compiler generates the nodes composing its syntax tree along with factory methods and visitor pattern implementations based on the contents of an \ac{XML} file. Therefore adding new nodes to represents the extended language constructs, such as the \bscode{atomic} block and \bscode{retry} statement, amounts to adding definitions for theses nodes to the \ac{XML}, allowing the employed tool to generate source code for the new nodes.
\item As described in \bsref{sec:syntax_trees} Roslyn's syntax trees are designed to be fast to modify by reusing underlying green nodes instead of creating complete copies\cite[p. 6]{ng2012roslyn}. This speaks for conducting transformation on the level of the syntax tree despite its immutable implementation.
\item The Roslyn project has been designed to allow programmers to utilize the information gather during the compilation process by analyzing the syntax tree as well as the information in the symbol table and the results of semantics analysis. These parts of the compiler are exposed as a public \ac{API} allowing access to both syntactical and semantic information. Utilizing this \ac{API} during the transformation phases allows the transformation to draw on the existing semantical analysis to answer questions such as, what method is the target of a method invocation, without the need for implementing complex analysis.
\item By parsing a extended syntax tree and transforming it into a regular C\# syntax tree the existing semantical analysis and code emission implementations can be utilized.
\end{enumerate}

\section{Lexer \& Parser Changes}
\label{sec:roslyn_lexer_parser_changes}

\andreas[inline]{Should contain lexer and parser changes, and the modifications to the syntax tree, and how it is made (XML changes)}	
\section{Syntax Tree Transformations}
\label{sec:syntax_tree_transformations}
%HUSK
\toby[i]{Evt. til valg af implementerings strategi: refer til at syntax træer kan blive modificeret hurtigt og med et lille memory overhead (den tredje key attribut omkring syntax træer)}
\kasper[inline]{Implementerings beskrivelse: error codes, lexer, parser, tvars, atomic block, replacement}

\subsection{Atomic Block}
Atomic and orElse block replacement

\subsection{Field Types}
\subsection{Properties}
\subsection{Local variables}
With or without type inference

\subsection{Member Accesses}
Accessing the .Value instead of the object directly

\subsection{Parameters}
Could also contain method and constructor argument replacement.

\subsection{Retry}

Steps in the transformation of the syntax tree (ordered as executed)
\begin{enumerate}
	\item Replace atomic properties
	\item Replace field types
	\item Replace atomic and orelse block
	\item Replace retry
	\item Replace local vars
	\item Replace method arguments
	\item Replace constructor arguments
	\item Replace member accesses
	\item Replace parameters
\end{enumerate}

(ordered as the design chapter)
\begin{enumerate}
	\item Replace atomic and orelse block
	\item Replace field types
	\item Replace atomic properties
	\item Replace local vars
	\item Replace member accesses
	\item Replace parameters (value, reference, out, params)
	\item Replace method arguments
	\item Replace constructor arguments
	\item Replace retry
\end{enumerate}
\worksheetend