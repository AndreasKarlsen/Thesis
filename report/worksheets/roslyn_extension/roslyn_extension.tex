\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Roslyn Extension}{0}{Februar 10, 2015}{}{../../}
The chapter describes how the Roslyn C\# compiler was extended to support the constructs of \stmname described in \bsref{chap:stm_design}. \bsref{sec:roslyn_extension_strategy} describes the overall strategy, \bsref{sec:roslyn_lexer_parser_changes} describes the changes made to the lexer and parser while \bsref{sec:syntax_tree_transformations} presents examples of the transformations made on the syntax tree by the extension.
\label{chap:roslyn_extension}
\section{Extension Strategy}
\label{sec:roslyn_extension_strategy}
The Roslyn C\# compiler was extended by modifying the lexing and parsing phases with support for the language construct described in \bsref{chap:stm_design}. The extended parsing phase outputs an extended syntax tree containing direct representations of the language features provided by \stmname. The syntax tree is then analyzed by identifying \stmnamesp constructs, followed by a transformation where any language extension is transformed into equivalent C\# code utilizing the \ac{STM} library described in \bsref{chap:implementation}. 

The transformation phase outputs a syntax tree containing only standard C\# code, executing the described \ac{STM} operations. This syntax tree is then passed to the remaining C\# compiler phases, utilizing its semantic analysis and code generation implementations. The approach is visualized in \bsref{fig:compiler_pipeline_extension}. The parser has been extended to output an extended syntax tree and transformation of this tree occurs before the binding and IL emission phases. The transformation phase utilizes both the extended syntax tree and symbol information gather through the Roslyn \ac{API}.
\begin{figure}[htbp]
\centering
 \includegraphics[width=1\textwidth]{\rootpath/worksheets/roslyn_extension/figures/compiler_pipeline_extension} 
 \caption{Extension occurs at the syntax tree and symbol level.}
\label{fig:compiler_pipeline_extension}
\end{figure}

The described approach was selected due to the following reasons:
\begin{enumerate}
\item As described in \bsref{subsec:roslyn_first_phase} the C\# lexer  uses a simple \bscode{switch} case to identify tokens by choosing the type of token to identify based on the first character of the token, while the parser uses a recursive descent technique, both of which are implemented by hand. Such techniques have a low degree of complexity compared to strategies such as \ac{LALR}. Thus modifying the lexer and parser is simpler than if more complex techniques had been employed.

\item The Roslyn compiler generate the nodes composing its syntax tree along with factory methods and a visitor pattern implementation based on the content of an \ac{XML} file. Therefore adding new nodes to represent the extended language constructs, such as the \bscode{atomic} block and \bscode{retry} statement, simply amounts to adding definitions for these nodes to the \ac{XML}, allowing the employed tool to generate source code for the new nodes. 

\item As described in \bsref{sec:syntax_trees} Roslyn's syntax trees are designed to be fast to modify by reusing underlying green nodes instead of creating complete copies\cite[p. 6]{ng2012roslyn}. This speaks for conducting transformation on the level of the syntax tree despite its immutable implementation.

\item The Roslyn project has been designed to allow programmers to utilize the information gathered during the compilation process, by analyzing the syntax tree, the information in the symbol table and the results of semantics analysis. These parts of the compiler are exposed as a public \ac{API} allowing access to both syntactical and semantic information. Utilizing this \ac{API} during the transformation phases allows the transformation to draw on the existing semantical analysis to answer questions such as, what method is the target of a method invocation, without the need for implementing complex analysis.

\item By parsing an extended syntax tree and transforming it into a regular C\# syntax tree, the existing semantical analysis and code emission implementations can be utilized.
\end{enumerate}
\andreas[inline]{What speaks against our approach? - Sing a song about that we chose this approach despite of the disadvantages. Refer to our restriction, about not modifying the CLR, which could be another approach}
\section{Lexing \& Parsing Phases}
This section describes the changes conducted in order to extend the lexing and parsing phases of the Roslyn C\# compiler to support the constructs described in \bsref{chap:stm_design}.
\label{sec:roslyn_lexer_parser_changes}

\subsection{Lexer Changes}
As described in \bsref{chap:stm_design}, \stmnamesp introduces three new keywords: \bscode{atomic}, \bscode{orelse} and \bscode{retry}. As a result the lexer component has been extended to identify these keyword as tokens of the correct kind. The C\# lexer initially lexes keyword tokens as if they where identifiers. If an identified token corresponds to a keyword, a keyword token with the correct kind is used instead. 

Allowing the lexer to identify the new keywords required adding their definition to the lookup methods of the \bscode{SyntaxKindFacts} class. The \bscode{SyntaxKindFacts} class defines the \bscode{GetKeywordKind} which the lexer uses to identify the keyword kind of an identifier, if the identifier represents a keyword. Additionally the \bscode{SyntaxKindFacts} class defines the \bscode{GetText} method for determining the string representation of a keyword based on its kind, to which a definition of the new keywords were added.

To allow a token to represent the new keywords, the \bscode{AtomicKeyword}, \bscode{OrelseKeyword} and \bscode{RetryKeyword} entries where added to the \bscode{SyntaxKind} enumeration. As described in \bsref{subsubsec:roslyn_kinds}, the \bscode{SyntaxKind} enumeration contains a entry for each type of node, token, or trivia in C\#. Whenever the lexer identifies a occurrence of one of the new keywords, with the corresponding kind is return. For example an occurrence of the \bscode{atomic} keyword results in a token with the kind \bscode{AtomicKeyword} being returned.

\subsection{Syntax Tree Extension}
The design described in \bsref{chap:stm_design} adds the \bscode{atomic}, \bscode{orelse} and \bscode{retry} constructs which the existing syntax tree cannot express. Therefore the syntax tree must be extended to support these language constructs. As described in \bsref{subsec:roslyn_syntax_tree_generation} nodes composing the syntax tree, along with factory methods and the visitor pattern implementation, are generated on the basis of an \ac{XML} file. Adding additional nodes to the the syntax tree therefore amounts to definition them in the \ac{XML} notation, which has been done for the three previously mentioned constructs. \bsref{lst:roslyn_extension_tre_xml} shows the \ac{XML} defining the \bscode{AtomicStatementSyntax} node which represents an \bscode{atomic} block in the syntax tree. Line 1 defines the name and base class of the the node while line 2 defines its kind. The \bscode{AtomicStatement} kind has been added to the \bscode{SyntaxKind} enumeration as described previously. Line 3 defines a property on the node which holds the token representing the \bscode{AtomicKeyword} which starts the definition of the atomic blocks. The property has a constraint specifying the kind on the token, that can be associated with the property which is defined on line 4 as well as a comment given on lines 5-9. Line 11 defines a statement property which holds the block of statements associated with the defined \bscode{atomic} block. Line 18 defines a property containing a \bscode{SyntaxList} of \bscode{orelse} blocks associated with the \bscode{atomic} block. This relationship has been modeled after the relationship between a C\# \bscode{try} statement and its \bscode{catch} clauses, as both have a zero to many association. Finally lines 25-27 defines a comment for the \bscode{AtomicStatementSyntax}, while line 28-30 defines a comment for the factory method.

\begin{lstlisting}[label=lst:roslyn_extension_tre_xml,
  caption={AtomicStatement \ac{XML} definition},
  language=XML,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  morekeywords={Name, Base, Type}]  % Start your code-block

  <Node Name="AtomicStatementSyntax" Base="StatementSyntax">
    <Kind Name="AtomicStatement"/>
    <Field Name="AtomicKeyword" Type="SyntaxToken">
      <Kind Name="AtomicKeyword"/>
      <PropertyComment>
        <summary>
          Gets a SyntaxToken that represents the atomic keyword.
        </summary>
      </PropertyComment>
    </Field>
    <Field Name="Statement" Type="StatementSyntax">
      <PropertyComment>
        <summary>
          Gets a StatementSyntax the represents the statement to be executed when the condition is true.
        </summary>
      </PropertyComment>
    </Field>
    <Field Name="Orelses" Type="SyntaxList&lt;OrelseSyntax&gt;">
      <PropertyComment>
        <summary>
          Gets a SyntaxList containing the orelse blocks associated with the atomic statement.
        </summary>
      </PropertyComment>
    </Field>
    <TypeComment>
      <summary>Represents an atomic block.</summary>
    </TypeComment>
    <FactoryComment>
      <summary>Creates an AtomicStatementSyntax node</summary>
    </FactoryComment>
  </Node>
\end{lstlisting}

Declaration of transactional local variables, fields and parameters does not require modifications to the syntax tree as the standard nodes for these constructs allow a collection of modifiers to be associated with the declaration. Any atomic modifiers are simply added to the collection along with any other modifiers. 


\subsection{Parser Changes}
As described in \bsref{subsec:roslyn_first_phase} the C\# parser uses a recursive decent strategy implemented by hand. As it is customary for recursive decent implementations, each construct has a method responsible for parsing that particular construct. For the new \bscode{atomic}, \bscode{orelse} and \bscode{retry} such a method has been added, while the methods for parsing local variable, field, parameters and properties have been modified to allow for a atomic modifier, as well as generating error messages for any unsupported modifier combinations such as \bscode{atomic const} and \bscode{readonly const}. Error are associated with the erroneous nodes as it is customary for the compiler. A later compilation phase generates error messages and cancels code emission if any errors where present.

\bsref{lst:parse_atomic_block} shows the \bscode{ParseAtomicBlock} method responsible for parsing a \bscode{atomic}. Line \ref{line:ab_keyword} parses a \bscode{atomic} keyword returning a token representing the keyword. Line \ref{line:ab_block} parses the block of statements representing the transaction body. Lines \ref{line:ab_orelse_start} to line \ref{line:ab_orelse_end} parses any \bscode{orelse} blocks associated with the \bscode{atomic} statement, if any are present. Line \ref{line:ab_allocate} allocates a \bscode{SyntaxListBuilder}. The \bscode{Allocate} method reuses existing space if possible, in order to limit the overhead of allocation. Line \ref{line:ab_parse_orelse} delegates the parsing of the actual \bscode{orelse} block to its corresponding method. Line \ref{line:ab_free} frees the space allocated by the call on on line \ref{line:ab_allocate}. The \bscode{try finally} construct ensures that the space is freed in case of an exception. Finally on line \ref{line:ab_return} the syntax factory is used to create the \bscode{AtomicStatementSyntax} that is returned.

\begin{lstlisting}[label=lst:parse_atomic_block,
  caption={Method for parsing \bscode{atomic} block},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  escapechar=~,
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  private StatementSyntax ParseAtomicBlock()
  { 
    var atomicKeyword = this.EatToken(SyntaxKind.AtomicKeyword);~\label{line:ab_keyword}~
    var block = this.ParseEmbeddedStatement(false);~\label{line:ab_block}~

    var orelses = SyntaxFactory.List<OrelseSyntax>();~\label{line:ab_orelse_start}~
    var orelseBuilder = _pool.Allocate<OrelseSyntax>();
    ~\label{line:ab_allocate}~
    try
    {
      while (this.CurrentToken.Kind == SyntaxKind.OrelseKeyword)
      {
        var clause = ParseOrelse();~\label{line:ab_parse_orelse}~
        orelseBuilder.Add(clause);
      }

      orelses = orelseBuilder.ToList();~\label{line:ab_tolist}~
    }
    finally
    {
      _pool.Free(orelseBuilder);~\label{line:ab_free}~
    }~\label{line:ab_orelse_end}~

    return _syntaxFactory.AtomicStatement(atomicKeyword, block, orelses);~\label{line:ab_return}~
  }
\end{lstlisting}
%error codes, const atomic, readonly atomic

\subsection{Symbol Changes}
The symbols representing fields, local variables, and parameters have been modified with a new \bscode{IsAtomic} property of type \bscode{bool}, indicating if they represent a atomic variation of these constructs. The logic which creates the symbol table has further been modified to, for each of these constructs, determine whether the declaration is atomic and set the \bscode{IsAtomic} to the appropriate value.

For each usage of a field, local variable or parameter, the semantic model allows for the retrieval of a symbol, representing the corresponding declaration. Based on the added \bscode{IsAtomic} property this symbol can be used to determine whether the usage represents the usage of a atomic variable. For cases where only access to atomic variable has be modified, the symbol extension allows easy access to the required information.


\section{Syntax Tree Transformations}
\label{sec:syntax_tree_transformations}
This section presents example of the syntax tree transformations performed during the compilation process. In order to prevent errors due to ambiguity between types names, the transformation process uses fully qualified names\cite[p. 73]{csharp2013specificaiton}  for any types in the \ac{STM} library. In the examples presented in this section the simple names have been used, in order to improve readability. 

\subsection{Atomic Block}
In \bsref{subsec:design_atomic_block} the design for the \bscode{atomic} block is described. \bsref{lst:before_atomic_block} depicts the syntax of the atomic block before transformation. 

\begin{lstlisting}[label=lst:before_atomic_block,
  caption={\bscode{atomic} Block Before Transformation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set}]  % Start your code-block

  atomic
  {
    //Block
  }
  orelse
  {
    //Orelse block
  }
\end{lstlisting}
The transformation of a atomic block is done over the four steps described bellow.
\begin{enumerate}
	\item Construct a syntax node for a lambda expression (anonymous function) with a body equal to that of the atomic block.
	\item Construct lambda expressions for any \bscode{orelse} blocks associated with the \bscode{atomic} blocks, preserving their bodies as with the \bscode{atomic} block.
	\item Construct a syntax node for the invocation of the \bscode{STMSystem.Atomic} method, giving the created lambda expressions as arguments.
	\item Replace the \bscode{atomic} block with the invocation of the \bscode{STMSystem.Atomic} method.
\end{enumerate}
For syntax shown in \bsref{lst:before_atomic_block} the transformation produces the output shown in \bsref{lst:after_atomic_block}.

\begin{lstlisting}[label=lst:after_atomic_block,
  caption={\bscode{atomic} Block After Transformation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set}]  % Start your code-block

  STMSystem.Atomic(() => {
    //Block					
  },
  () => {
    //Orelse block
  });
\end{lstlisting}

\subsection{Field Types}\label{subsec:extension_field}
\subsection{Properties}
In \bsref{subsec:design_properties} we described the design for transactional properties. The automatic form is exemplified in \bsref{lst:before_atomic_property}:

\begin{lstlisting}[label=lst:before_atomic_property,
  caption={Before Transformation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Car {
      public atomic int KmDriven { get; set; }
  }
\end{lstlisting}

In order to provide the wanted semantics, we transform it into two parts: an atomic backing field (line 2), and a manual property (line 3-11). Thus, after the transformation, the example in \bsref{lst:before_atomic_property} becomes \bsref{lst:after_atomic_property}. 

\begin{lstlisting}[label=lst:after_atomic_property,
  caption={After Transformation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  class Car {
    private atomic int _kmDriven;
    public int KmDriven {
        get {
            return _kmDriven;
        }
        set {
            _kmDriven = value;
            // Announce value changes
        }
    }
  }
\end{lstlisting}

The transformation takes the following approach for each transactional property identified in the syntax tree:

\begin{enumerate}
	\item Constructs a get-body with the access-modifier of the original propertys get. The get-body contains a block in which a return to the backing field is. The backing field is not yet constructed, but a method is used to determine its future identifier to ensure a correct reference.
	\item Constructs a set-body with the access-modifier of the original propertys set. The set-body contains a block in which an assignment of \bscode{value} is made to the backing field.
	\item Constructs a manual property with the access modifier of the original property, the get-body and set-body constructed earlier.
	\item Constructs a private transactional field of the same type as the original property.
\end{enumerate}
The code performing the transformation can be found in \andreas{STM.cs - ReplaceProperties(SyntaxNode root)}

The transactional properties are transformed before the transactional fields, thus enabling reuse of the transformation done for atomic fields, as the backing field can be constructed as a transactional field instead of fully transforming it. Additionally, no transformation has to be done for the manual form, as the transactional field used for backing the property is processed as described in \bsref{subsec:extension_field}. 

\andreas[inline]{We dont secure that the generated backing field does not already exist.}

\subsection{Local variables}
With or without type inference

\subsection{Usage of Transactional Variables}
As described in \bsref{subsec:stm_impl_transactional_variables} setting the value of a transactional variable is done trough the \bscode{Value} property of the supplied \ac{STM} types. As the type of any field, local variable or property declared \bscode{atomic} in \stmnamesp is changed to the corresponding \ac{STM} type, any assignment must go trough the \bscode{Value} property. As described in \bsref{subsec:stm_impl_transactional_variables} the \ac{STM} types supply support for implicit conversion to the wrapped value, when appearing as r-values. The transformation can however not rely on implicit conversion in all cases as, for example the comparison of to \bscode{TMInt} objects results in reference comparison instead of the intended integer comparison. As such, also the r-value appearances of any transactional field, local variable and parameter must be transformed to access the \bscode{Value} property ensuring that the wrapped object is accessed instead of the \ac{STM} object. Special handling is given to the \bscode{++} and \bscode{--} operators as the numeric \bscode{STM} types supply transactional implementations of these operators. The transformation ensures that these operators access the \ac{STM} object directly instead of access the \bscode{Value} property.

The implementations for the transformation of access to transactional variables are divided into two parts. The first dealing with the usage of transnational variables occurring as a single identifier such as \bscode{someTMVar}. The second part handles member access expressions such as \bscode{object.someTMfield.someOtherTMfield}. While these two implementations differ in the syntactic constructs they work on, their overall approach both follow the steps described below:

\begin{enumerate}
	\item Identify each usage of a transactional field, local variable, or parameter including both r and l-value occurrences.
	\item Construct a member access expression accessing the \bscode{Value} property of the identified variable.
	\item Replace the usage of the variable with the constructed member access expression. 
\end{enumerate}

\bsref{lst:before_atomic_usage} presents a example accessing both a transactional field, local variable and parameter. \bsref{lst:after_atomic_usage} shows the result of applying the transformation to the example presented in \bsref{lst:before_atomic_usage}. The assignment on line \ref{line:au_assigment} of \bsref{lst:before_atomic_usage} is transformed to access the \bscode{Value} property of both its left and right sides, as both of the variable involved are transactional. The result of the transformation is shown on line \ref{line:au_assigment_after} of \bsref{lst:after_atomic_usage}. The member access expression on line \ref{line:au_member_access} of \bsref{lst:before_atomic_usage} is likewise transformed to access the \bscode{Value} property of both transactional fields involved. The resulting code is shown on line \ref{line:au_member_access_after} of \bsref{lst:after_atomic_usage}.

\begin{lstlisting}[label=lst:before_atomic_usage,
  caption={Usage of \bscode{atomic} Variables Before Transformation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set}]  % Start your code-block

  public class AtomicExample
  {
    public atomic AtomicExample aField;

    public AtomicExample ExampleMethod(atomic int i)
    {
      atomic int k = 0;
      k = i;~\label{line:au_assigment}~

      return aField.aField;~\label{line:au_member_access}~
    }
  }
\end{lstlisting}

\begin{lstlisting}[label=lst:after_atomic_usage,
  caption={Usage of \bscode{atomic} Variables After Transformation},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set}]  % Start your code-block

  public class AtomicExample
  {
    public TMVar<AtomicExample> aField = new TMVar<AtomicExample>();

    public AtomicExample ExampleMethod(TMInt i)
    {
      TMInt k = new TMInt(0);
      k.Value = i.Value;~\label{line:au_assigment_after}~

      return aField.Value.aField.Value;~\label{line:au_member_access_after}~
    }
  }
\end{lstlisting}

\subsection{Parameters}
Could also contain method and constructor argument replacement.

\subsection{Retry}

Steps in the transformation of the syntax tree (ordered as executed)
\begin{enumerate}
	\item Replace atomic properties
	\item Replace field types
	\item Replace atomic and orelse block
	\item Replace retry
	\item Replace local vars
	\item Replace method arguments
	\item Replace constructor arguments
	\item Replace member accesses
	\item Replace parameters
\end{enumerate}

(ordered as the design chapter)
\begin{enumerate}
	\item Replace atomic and orelse block
	\item Replace field types
	\item Replace atomic properties
	\item Replace local vars
	\item Replace member accesses
	\item Replace parameters (value, reference, out, params)
	\item Replace method arguments
	\item Replace constructor arguments
	\item Replace retry
\end{enumerate}

\section{Design \& Integration revisited}
Changes to design due to limited implementation possibilities.
\worksheetend