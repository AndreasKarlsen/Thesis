\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Roslyn Extension}{0}{Februar 10, 2015}{}{../../}
The chapter describes how the Roslyn C\# compiler was extended to support the constructs of \stmname. \bsref{sec:roslyn_extension_strategy} describes the over all strategy, \bsref{sec:roslyn_extension_strategy} describes the changes made to the lexer and parser while \bsref{sec:syntax_tree_transformations} presents examples of the transformations made by the extension.
\label{chap:roslyn_extension}
\section{Extension Strategy}
\label{sec:roslyn_extension_strategy}
The Roslyn C\# compiler was extended by modifying the lexing and parsing phases with support for the language construct described in \bsref{chap:stm_design}. The extended parsing phase outputs a extended syntax tree containing direct representations of any utilized \ac{STM} language extensions. The syntax tree is then analyzed, transforming any language extension into equivalent C\# code utilizing the \ac{STM} library described in \bsref{chap:implementation}. The transformation phase outputs a syntax tree containing only standard C\# code, executing the described \ac{STM} operations. This syntax tree is then passed to the reaming C\# compiler phases, utilizing its semantic analysis and code generation implementations. The approach is visualized in \bsref{fig:compiler_pipeline_extension}. The parser has been extended to output a extended syntax tree and transformation of this tree occurs before the binding and IL emission phases. The transformation phase utilizes both the extended syntax tree and symbol information gather trough the Roslyn C\# compilers \ac{API}.
\begin{figure}[htbp]
\centering
 \includegraphics[width=1\textwidth]{\rootpath/worksheets/roslyn_extension/figures/compiler_pipeline_extension} 
 \caption{Extension occurs at the syntax tree and symbol level.}
\label{fig:compiler_pipeline_extension}
\end{figure}

The described approach was selected due to the following reasons:
\begin{enumerate}
\item As described in \bsref{subsec:roslyn_first_phase} the C\# lexer  uses a simple \bscode{switch} case to identify tokens by choosing the type of token to identify based on the first character of the token, while the parser uses a recursive descent technique, both of which are implemented by hand. Such techniques have a low degree of complexity compared to strategies such as \ac{LALR}. As such modifying the lexer and parser is simpler than would be the case if more complex techniques had been employed.
\item The Roslyn compiler generates the nodes composing its syntax tree along with factory methods and visitor pattern implementations based on the contents of an \ac{XML} file. Therefore adding new nodes to represents the extended language constructs, such as the \bscode{atomic} block and \bscode{retry} statement, amounts to adding definitions for theses nodes to the \ac{XML}, allowing the employed tool to generate source code for the new nodes.
\item As described in \bsref{sec:syntax_trees} Roslyn's syntax trees are designed to be fast to modify by reusing underlying green nodes instead of creating complete copies\cite[p. 6]{ng2012roslyn}. This speaks for conducting transformation on the level of the syntax tree despite its immutable implementation.
\item The Roslyn project has been designed to allow programmers to utilize the information gather during the compilation process by analyzing the syntax tree as well as the information in the symbol table and the results of semantics analysis. These parts of the compiler are exposed as a public \ac{API} allowing access to both syntactical and semantic information. Utilizing this \ac{API} during the transformation phases allows the transformation to draw on the existing semantical analysis to answer questions such as, what method is the target of a method invocation, without the need for implementing complex analysis.
\item By parsing a extended syntax tree and transforming it into a regular C\# syntax tree the existing semantical analysis and code emission implementations can be utilized.
\end{enumerate}

\section{Lexer \& Parser Changes}
\label{sec:roslyn_lexer_parser_changes}


\section{Syntax Tree Transformations}
\label{sec:syntax_tree_transformations}
%HUSK
\toby[i]{Evt. til valg af implementerings strategi: refer til at syntax træer kan blive modificeret hurtigt og med et lille memory overhead (den tredje key attribut omkring syntax træer)}
\kasper{Implementerings beskrivelse: error codes, lexer, parser, tvars, atomic block, replacement}
\worksheetend