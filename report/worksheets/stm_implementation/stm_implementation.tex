\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{STM Implementation}{0}{Februar 10, 2015}{}{../../}
This chapter describes the implementation of the \ac{STM} system that executes transactions in \stmname. Various implementation algorithms have been proposed for \ac{STM} of which a few were briefly described in \bsnameref{sec:intro_related_work}. This chapter covers the considerations which went into selecting an algorithm for \stmname. Specific attention is payed to the requirements and design choices made in \bsref{sec:stm_requirements} and \bsref{chap:stm_design}. Based on this overview an algorithm will be selected. As the goal of this thesis is to evaluate if language integrated \ac{STM} is an alternative to locks, building on an existing algorithm is the logical choice, rather than developing a new.
\andreas{Should we have the: in 6.1 bla bla, 6.2 bla?}\toby{good idea}
\kasper[inline]{Strong atomicity implementation description}
\label{chap:implementation}
\section{Implementation Criteria}
\label{sec:stm_impl_criteria}
This section describes a number of criteria which have an influence on the choice of \ac{STM} algorithm.

\subsection{Strong Atomicity}
As described in \bsref{sec:design_strong_weak_atomicity} strong atomicity ensures atomicity between transactional and non-transactional access. As \stmnamesp is required to support strong atomicity the implementation strategy should facilitate such access.

Lazy update inherently supports non-transactional reads as the value associated with transactional variables is always the most recently committed value\cite[p. 2084]{herlihy2011tm}\cite[p. 21]{harris2010transactional}. Thus a non-transactional read can never read a non-committed value and atomicity is ensured because a single non-transactional read always reads the most recently committed value of a transactional variable. Ensuring atomicity for non-transactional reads is also possible using eager updating, but may incur some overhead in selecting the correct value to read. \andreas{Source or explanation?}

Although non-transactional writes to transactional variables cannot conflict with one another, they must be tracked by the \ac{STM} system in order to ensure that any transactions with which they conflict are aborted and retried. In \cite{hindman2006atomicity} Hindman et al. proposes the concept of mini-transactions. By encapsulating non-transactional access to transactional variables in a transaction, mini-transactions allow the \ac{STM} system to track their actions. This enables reading and writing to transactional variables from non-transactional code, while ensuring strong atomicity\andreas{Kasper, vil du verify?}. Their approach goes even further, supplying optimized non-transactional access which skips much of the unnecessary logging required for normal transactions. As \stmnamesp will benefit from using the described approach, the algorithm selected should be capable of supporting it.
 
\subsection{Conditional Synchronization}
\label{subsec:stm_impl_selection_conditional}
The \bscode{retry} construct described in \bsref{sec:req_conditional} requires knowledge of which transactional variables have been read, up to the point where a retry is requested\cite{harris2005composable}. The \ac{STM} system needs to maintain a set of transactional variables which has been read, for all active transactions, so that a transaction can be blocked until one of these variables change. Such a set is often referred to as a read-set\cite{dice2006transactional}\cite{harris2010transactional}\cite{herlihy2012art}. \ac{STM} systems employing lazy conflict detection commonly use such a set to record reads for validation when the transaction is about to commit\cite{dice2006transactional}\cite{mohamedin2013bytestm}. Choosing an algorithm which already maintains a read-set will limit the overhead of the \bscode{retry} statement as well as simplify the implementation as the algorithm must not be modified to support the accumulation of a read-set. Thus selecting an algorithm which inherently supports a read-set is a priority.

\subsection{Library Implementation}
As described in \bsref{}\kasper{HUSK REFERENCE!} the \ac{STM} system of \stmnamesp must be implemented as a .NET library. The strategy employed must not entail details which require changes to the runtime system as seen by a number of \ac{STM} implementations\cite{mohamedin2013bytestm}\cite{harris2003language}. Furthermore we aim at providing a library with an \ac{API} that facilitates use from both compiler generated code and regular C\# programs.\andreas{Forklar hvorfor, eller skriv udvid problem formulering}
\andreas[inline]{Overvej at flytte dette til et andet kapitel}

\subsection{Progress Guarantee}
\ac{STM} algorithms can coarsely be divided into blocking and non-blocking algorithms\cite[p. 47]{harris2010transactional}. Blocking algorithms employ some form of locking in order to ensure atomicity, while non-blocking do not\cite[p. 59]{herlihy2012art}. Non-blocking algorithms guarantee that the failure of one thread does not keep other threads from making progress\cite[p. 47]{harris2010transactional}\cite[p. 142]{herlihy1991wait}\cite[p. 59]{herlihy2012art}. This  makes it impossible to employ locking, as the failure of some thread $T$, which is holding a lock, will keep other threads from acquiring the lock, and thereby from progressing. Non-blocking algorithms can further be distinguished by the progress guarantees they provide. 
\begin{itemize}
	\item Wait-freedom is the strongest of these, and guarantees that any thread makes progress on its own work if it keeps executing\cite[p. 124]{herlihy1991wait}\cite[p. 59]{herlihy2012art}. 
	\item Lock-freedom is less strict as it only guarantees that if a thread $T$ keeps executing then some thread (not necessarily $T$) makes progress\cite[p. 47]{harris2010transactional}\cite[p. 60]{herlihy2012art}. 
	\item The least strict progress guarantee is obstruction-freedom\cite[p. 47]{harris2010transactional}\cite{herlihy2003obstruction}\cite[p. 61]{herlihy2012art}. As mentioned in \bsref{sec:intro_related_work}, obstruction-freedom guarantees that any thread which runs for long enough without encountering a synchronization conflict makes progress\cite[p. 1]{herlihy2003obstruction}. 
\end{itemize}
Any wait-free algorithm is also lock-free and any lock-free algorithm is also obstruction-free, but not vice versa\cite[p. 60]{herlihy2012art}\lone{Hvorfor ikke, forklar}. While all of these progress guarantees preclude deadlocks, only wait-freedom and lock-freedom preclude livelocks\cite[p. 47]{harris2010transactional}. Obstruction free algorithms have been shown to provide efficient implementations in practice\cite[p. 61]{herlihy2012art}, especially when paired with techniques such as exponential backoff\cite[p. 147]{herlihy2012art} and contention managers\cite[p. 51]{harris2010transactional}.

Whether \ac{STM} implementations need to be wait-free, lock-free, obstruction-free or even provide any of these guarantees at all is an ongoing discussion\andreas{Where? In the research community? At our group?}. Arguments have been made for even obstruction-freedom being too strong a guarantee and that \ac{STM} can be made faster by employing controlled locking\cite{ennals2006software}. Due to the complexities associated with non-blocking algorithms\cite{al2013nonblocking}\cite[p. 61]{herlihy2012art} and the evidence that blocking \ac{STM} systems can perform well in practice\toby{skal vi have en ref? eller har vi det tidligere?}, we initially choose to focus on blocking \ac{STM} algorithms. We do however keep the option of moving to a non-blocking algorithm after producing an initial implementation, as demonstrated by Fernandes et al. in \cite{fernandes2011lock}. Due to the limited applicability of C\#'s volatile keyword\cite[p. 302]{csharp2013specificaiton} ensuring that the most recently written value is always read without resorting to locking can be problematic for the non supported types.\toby{Måske mere uddybende om denne problematik? Ikke sikker.} Choosing a locking implementation mitigates this issue.

%Older \ac{STM} systems tend to be either lock-free or obstruction-free\cite[p. 47]{harris2010transactional} while blocking \ac{STM} systems have emerged in an attempt to tune performance\cite[p. 51]{harris2010transactional}.


\section{Selection of Algorithm}
%%Choice of implementation based on previous sections and requirements
%TL2 \cite{dice2006transactional}\\
%TinySTM \cite{felber2008dynamic}\\
%McRT \cite{saha2006mcrt}\\
%JVSTM \cite{cachopo2007development}\\
%JVSTM-lock-free\cite{fernandes2011lock}\\
%\cite{herlihy2003software}\\
%\cite{hendler2011nonblocking} lockfree starve.

By investigating a number of different \ac{STM} implementations, the field on which the final selection is based, was narrowed down to the following: McRT\cite{saha2006mcrt} developed by Saha et al., TL\rom{2}\cite{dice2006transactional} developed by Dice et al. and JVSTM\cite{cachopo2007development} developed by Cachopo. McRT and TL\rom{2} are frequently referenced in the research community and JVMSTM is a newer implementation. All of these systems employ locking but in different ways. The algorithms vary greatly in other areas and will provide a broad perspective on possible \ac{STM} implementations.\andreas{Cite sources?}

\subsection{McRT}
\label{sec:stm_impl_mcrt}
McRT employs encounter time locking\toby{første gang det nævnes, skal det forklares? Fra wiki: memory writes are done by first temporarily acquiring a lock for a given location, writing the value directly, and logging it in the undo log(Ennals, Saha, and Harris)} and supports two algorithms for synchronization\cite[p. 189]{saha2006mcrt}. The first is based on reader-writer locks that allows multiple readers to hold the lock simultaneously, while a writer must have exclusive access\cite[p. 189]{saha2006mcrt}. The second is based on versioned locks where each lock has an associated version number\cite[p. 108]{harris2010transactional}. We focus only on the second approach as this has been shown to have the best performance\cite[p. 190]{saha2006mcrt}. \andreas{Do we care about performance?}

McRT uses eager updates as this avoids having to check a write-set for a non-committed version of an item, when a read to that item occurs\cite[p. 109]{harris2010transactional}. Locking allows the system to guarantee that no transaction reads a value which has not yet been committed\cite[p. 108]{harris2010transactional}. Eager updates require the system to maintain an undo list which keeps track of the old values of transactional variables to which a given transaction has written. The undo list is used to revert any items, to which a given transaction has written, to their previous state in case of an abort\cite[p. 189]{saha2006mcrt}. Eager update makes the commit phase faster as no writes have to be redone\cite[p. 190]{saha2006mcrt}. The versioned lock algorithm of McRT requires maintaining a read-set which must be validated as part of the commit process, similar to TL\rom{2} which we describe in the next section. The read-set contains a record of every item read as well as the version number of the item at the time of reading. During the commit phase the read-set of a transaction is validated, ensuring that no read item has a higher version number than the version number present when the item was read\cite[p. 190]{saha2006mcrt}.

As McRT uses eager updating, conflicts will arise before transactions are allowed to commit. Therefore McRT detects conflicts only against active transactions\cite[p. 189]{saha2006mcrt}. Aborting transactions due to a conflict with an active transaction can lead to cases where e.g. a transaction \bscode{t1} is aborted due to a conflict with a \bscode{t2} transaction, but \bscode{t2} is aborted before it can commit due to a conflict with some transaction \bscode{t3}\cite[p. 2084]{herlihy2011tm}. \bscode{t1} could have been allowed to continue as the transaction with which it conflicted never committed. 

Conflicts between transactions appear as contention on the locks in the system. If multiple transactions attempt to acquire a lock on the same item a conflict is about to occur. In such cases McRT prefers letting transactions\lone{en el flere?} wait for the lock over aborting one of the involved transactions, in order to increase throughput\cite[p. 189]{saha2006mcrt}.

\subsection{TL\rom{2}}
\label{sec:stm_impl_tl2}
As briefly described in \bsref{sec:intro_related_work}, TL\rom{2} only holds locks during the commit process\cite[p. 199]{dice2006transactional}. This is known as commit time locking. TL\rom{2} uses lazy updates where writes are recorded in a write-set and written to the associated memory when the transaction commits. Additionally, any reads performed by a transaction are recorded in a read-set used to validate the transaction before it commits the content of its write-set\cite[p. 198]{dice2006transactional}. The accumulation of a read-set for the \bscode{retry} will therefore incur no additional overhead.

TL\rom{2} uses a global version clock to ensure atomicity\cite[p. 201]{dice2006transactional}. Transactions record a time-stamp when they start. The time-stamp is used to validate the contents of the read-set before the transaction commits. Each item tracked by the \ac{STM} system has an associated time-stamp which is updated when a transaction commits a new value. If any item in the read-set has a time-stamp higher than transactions time-stamp then the item has been modified while the transaction was executing. As a result the transaction must abort and restart.

In order to commit, a transaction must go through the following steps\cite[p. 200]{dice2006transactional}:
\begin{enumerate}
\item Acquire the lock on each item in the write-set
\item Increment and fetch the version clock
\item Validate the read-set as described above
\item Commit values in the write-set along with the new time-stamps
\item Release the lock on each item in the write-set
\end{enumerate}

The transaction has exclusive access to the items in the write set during the commit phase and detects conflicts lazily against previously committed transactions. 

The version clock can be a source of contention as all transactions must increment the version clock as part of the commit operation\cite[p. 120]{harris2010transactional}. A number of ways of reducing contention has been proposed \cite{zhang2008commit}\cite{lev2009anatomy}\cite{avni2008maintaining}.

The base TL\rom{2} algorithm can lead to false negatives when validating the read-set. If a transaction \bscode{t2} executes in between the reading made by transaction \bscode{t1} of the global clock and reading its first value, \bscode{t2} will then have incremented the version clock and the time-stamp of \bscode{t1} will be invalid before it starts executing its transaction, even though the transaction would be valid if it occurred after \bscode{t2}. In \cite{riegel2007time} Riegel et al. propose an attempt to update a transactions time-stamp in order to eliminates such false negatives.

\subsection{JVSTM}
JVSTM uses \ac{MVCC}\cite[p. 1]{fernandes2011lock}, as known from databases\cite[p. 791]{elmasri2011fundamentals}. \ac{MVCC} requires the \ac{STM} system to keep a record of the old values for any item that is tracked\cite[p. 791]{elmasri2011fundamentals}. Reads that would be invalid in a system maintaining only the most recent value for each item, can be redirected to read an older value, allowing the associated transaction to continue\cite[p. 791]{elmasri2011fundamentals}. As a result JVSTM guarantees that read only transactions will always be able to commit\cite[p. 97]{cachopo2007development}.

To keep track of the values associated with an item JVSTM uses what the original designer calls a versioned box\cite[p. 63]{cachopo2007development}. A version box is an abstraction for an item to be tracked, such as a variable. Each version box keeps an ordered sequence of values, called the history of the versioned box. This sequence represents the values that have been committed to the item. Each transaction and version in the history of a versioned box is assigned a version number indicating when the transaction started and when the value was created.

JVSTM uses lazy updates, buffering writes in a transactional local write-set\cite[p. 64]{cachopo2007development}. As with TL\rom{2}, writes are written to the tracked item when the transaction commits. Reads from a versioned box first check if the transactions write-set contains a non-committed value, returning it if that is the case\cite[p. 64]{cachopo2007development}. If no such item exists, the history of the versioned box is searched for a suitable value. The first value that has a version number less than or equal to the transactions version number is returned\cite[p. 64]{cachopo2007development}.

The initial version of JVSTM uses a single global lock to ensure atomicity between committing transactions\cite[p. 70]{cachopo2007development}, forcing the commit phase to be executed sequentially even though two transactions may not be committing to the same versioned boxes. A lock-free variation of JVSTM, correcting this issue, is proposed in \cite{fernandes2011lock}.

Keeping the old values for each tracked item takes up additional space and the space consumption increases as new versions are added. Over time some old values might no longer be needed and can therefore be removed. To handle this JVSTM implements a thread responsible for this task\cite[p. 70]{cachopo2007development}\cite[p. 88]{cachopo2007development}, similar to a garbage collector\cite[p. 472]{fischer2009crafting}.

%read of values
\subsection{Final Selection}
Based on the criteria presented in \bsref{sec:stm_impl_criteria}, the requirements defined in \bsref{sec:stm_requirements} and the intended design presented in \bsref{chap:stm_design} it has been decided to base the \ac{STM} implementation on the TL\rom{2} algorithm. 

TL\rom{2} uses lazy updating which simplifies the implementation of strong atomicity as a non-transactional read can access a value directly. Additionally the algorithm makes use of a read-set which simplifies the implementation of the \bscode{retry} construct. An extension to TL\rom{2} presented in \cite[p. 107]{harris2010transactional} allows support for opacity, which fulfills the requirement presented in \bsref{sec:stm_req_opacity}. Furthermore the TL\rom{2} algorithm are well documented from multiple sources, including a library based implementation\cite{dice2006transactional}\cite[p. 438]{herlihy2012art}\cite[p. 106]{harris2010transactional}.

McRT was discarded as its eager updating strategy based on locking may require non-transactional reads to wait. If an active transaction \bscode{t1} has written a value to some variable \bscode{x} and a non-transactional read to \bscode{x} occurs, the non-transactional read would have to wait for \bscode{t1} to finish in order to ensure that the value read is not rolled back at a later point. Additionally conflict detection against active transactions can lead to unnecessary aborts as described in \bsref{sec:stm_impl_mcrt}.

JVSTM's use of the well known \ac{MVCC} approach to transactions facilitates a guarantee that read-only transactions will always be able to commit. While this is an attractive property, \ac{MVCC} also requires a garbage collection thread tasked with removing old values that can no longer be read, thereby complicating the implementation. Additionally, the lock based version of JVSTM uses commit phases which execute sequentially due to global locking. As a result the scalability of the  JVSTM algorithm is reduced\cite[p. 86]{cachopo2007development}.
 
While performance of the \ac{STM} system, as described in \bsref{sec:scope}, is not the primary concern of this thesis we do not believe that closing our eyes completely to this factor is the correct approach. Multiple different algorithms are available and we have aimed at selecting one that fulfills the requirements with only minimal performance sacrifices. 

\andreas[inline]{We must mention why performance matters, even though we do not care in the evaluation}

%opacity


%\subsubsection{DSTM}
%By investigating a number of different \ac{STM} implementations the field, on which the final selection is based, was narrowed down to the obstruction-free DSTM presented in \cite{herlihy2003software}, the lock-free variation of JVSTM presented in \cite{fernandes2011lock} and lock based TL2 presented in \cite{dice2006transactional}. All of these implementations contribute with a \ac{STM} library intended to be used directly by the programmer\cite[p. 92]{herlihy2003software}\cite[p. 73]{cachopo2007development}\cite[p. 38]{lourencco2007testing}. DSTM was selected based on its impact on both obstruction-free \ac{STM} and  \ac{STM} in general. JVSTM was selected as it represents a lock-free \ac{STM} system build for the Java programming language, which has a number of similarities with C\#.
%
%As briefly described in \bsref{sec:intro_related_work}, DSTM is a obstruction-free \ac{STM} library for the Java and C++ programming languages. DSTM uses transactional objects which encapsulate regular objects and provide transactional access. Conflict detection occurs at object level which is the opposite of the requirement defined in \bsref{sec:tracking}. The value of a transactional object is represented by a locator object which is updated using a Compare-And-Swap operation\cite{herlihy2003software}[p. 95]. The locator contains a reference to the transaction which installed the locator, a new value and a old value. Based on the status of the transaction which installed the current locator a reading transaction can choose to read the old or new value. If the status is \bscode{Committed} the new value is the correct value, if the status is \bscode{Aborted} the old value is the correct value. The case where the status is \bscode{Active} indicates that a conflict is about to occur and that the involved transactions should contact the contention manager in order to resolve the conflict\cite{herlihy2003software}[p. 97]. As such the implementation employees eager updating and eager conflict detection\cite[p. 96]{herlihy2003software}. Committing and a aborting a transaction is reduced to changing the status of a transaction to \bscode{Commited} or \bscode{Aborted} using a Compare-and-Swap operation. Each transactional object will have the status associated with its locator changed by the same operation
%
%Non-transactional reads can be supported by choose the correct value to read. A read can occur similar to a transactional read. That is reading the new value if the status is \bscode{Committed} or the old value if status is \bscode{Aborted}. If the status is \bscode{Active} the old value should be read, causing the non-transactional read to occur before the transaction which installed the current locator. Choosing the correct value to read, as opposed to simply reading the most recently committed value which lazy updating allows, does however cause some overhead. Non-transactional writes can be accomplished by expanding the writes to mini transactions as described in \bsref{subsec:stm_impl_selection_conditional}.
%
%The base algorithm has no need for a read-set as any read is communicated to other transactions by installing a new locator specifying that the transaction has accessed the transactional object. Supporting the \bscode{retry} construct requires adding support for a read-set by modifying the existing algorithm.
%%Object based conflict detection.
%
%The base DSTM algorithm does not support concurrent reads as the locator objects does not allow distinguishing a read from a write operation\cite[p. 435]{herlihy2012art}. As concurrent reads is one of the major advantages offered by \ac{STM}'s optimistic approach to shared memory concurrency, the algorithm must be modified to support such operations in order to be useful in practice.


\section{Library Interface} 
\label{sec:stm_library_interface}
The \ac{STM} system which executes transactions in \stmnamesp is implemented as a C\# library\andreas{Can we reference to a design decision?}. Transactions are started by using one of the overloads of the static \bscode{Atomic} method on the \bscode{STMSystem} class. The static method \bscode{Atomic} is overloaded with support for transaction with and without return values as well as specification of zero to many \bscode{orelse} blocks. \bsref{lst:library_atomic} presents an example of transaction declarations. On lines 5-8 the simple transaction declaration corresponding to the \bscode{atomic} block is shown. Lines 10-14 depict the declaration of a transaction with a return value. Finally lines 16-23 depict the declaration of a transaction with an associated \bscode{orelse} block. 

\begin{lstlisting}[label=lst:library_atomic,
  caption={Library Transaction Declaration},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  public class TransactionExamples {
    
    public static void AtomicExample
    {
      STMSystem.Atomic(() =>
      {
        //Transaction body
      });

      var result = STMSystem.Atomic<int>(() =>
      {
        //Transaction body
        return 1;
      });
      
      STMSystem.Atomic(() =>
      {
        //Transaction body
      },
      () =>
      {
        //orelse body
      });
    }
  }
\end{lstlisting}

\subsection{Transactional Variables}
\label{subsec:stm_impl_transactional_variables}
Transactional variables are created by declaring instances of the generic \bscode{TMVar} class. Instances of the \bscode{TMVar} class wrap an object to which transactional access is provided.  The constructor of the \bscode{TMVar} class takes a type parameter specifying the type which the \bscode{TMVar} instance wraps.

The \bscode{TMVar} class exposes methods and the \bscode{Value} property for getting and setting the wrapped object. Any access through the exposes methods and the \bscode{Value} property are tracked by the \ac{STM} system, both transactional and non-transactional. Furthermore the \bscode{TMVar} class uses C\#'s implicit conversion feature to allow a \bscode{TMVar} to implicitly be converted to the enclosed value whenever the \bscode{TMVar} occurs as an r-value. Special types, deriving from \bscode{TMVar}, are supplied for the common types \bscode{int}, \bscode{long}, \bscode{float}, \bscode{double} \bscode{uint} and \bscode{ulong}. These types supply transactional support for common operations such as \bscode{++} and \bscode{--} which are executed on the enclosed object. \bsref{lst:library_tmvar}  shows the declaration of a number of transactional variables. Lines 5-7 use the generic \bscode{TMVar} class to wrap objects of various types. Line 8 declare a \bscode{TMInt}, which is the specialized type for transaction integers. Lines 11-17 declares a transaction that on line 13 check if the boolean value wrapped by \bscode{tmBool} is true and the string value wrapped by \bscode{tmString} is equal to the string \bscode{"abc"}. \bscode{tmBool} and \bscode{tmString} are implicitly converted to the wrapped value while preserving transactional access, allowing the transactional variable to be used as if it were an instance of the enclosed type. Line 15 uses the \bscode{++} operator supported by the \bscode{TMInt} type.
\begin{lstlisting}[label=lst:library_tmvar,
  caption={Library Transactional Variable},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, string, bool}]  % Start your code-block

  public class TransactionExamples {
      
    public static void TMVarExample()
    {
      TMVar<string> tmString = new TMVar<string>("abc");
      TMVar<bool> tmBool = new TMVar<bool>();
      TMVar<Person> tmPerson = new TMVar<Person>(new Person("Bo Hansen", 57));
      TMInt tmInt = new TMInt(12);
           

      STMSystem.Atomic(() =>
      {
        if (tmBool && tmString == "abc")
        {
          tmInt++;
        }
      });
    }
  }
\end{lstlisting}
\subsection{Retry}\label{subsec:impl_retry}
The library supports the \bscode{retry} construct via the static \bscode{Retry} method on the \bscode{STMSystem} class. The retry method can be called from both in and outside transactions but will only have an effect when called inside transactions. \bsref{lst:library_retry} presents an example of how the \bscode{Retry} method can be used. Lines 5-11 show a transaction dequeuing an item from a shared buffer. On line 8 the \bscode{Retry} method is used to initiate a retry in case the queue is empty. The call on line 15 has no effect as it is not enclosed in a transaction. However if the \bscode{RetryExample} method is called from within another transaction, the \bscode{Retry} has effect\andreas{Do we want to warn if this happens?}.

\begin{lstlisting}[label=lst:library_retry,
  caption={Library \bscode{Retry}},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  public class TransactionExamples {
    
    public static void RetryExample(Queue<Person> buffer)
    {
      Person result = STMSystem.Atomic(() =>
      {
        if (buffer.Count == 0)
          STMSystem.Retry(); //Initiates retry

        return buffer.Dequeue();
      });
      
      //Work with the result

      STMSystem.Retry(); //Has no effect
    }
  }
\end{lstlisting}
\subsection{Nesting}
The \ac{STM} library supports both lexical and dynamic nesting of transactions. Lexical nesting is achieved by specifying a transaction within the body of another transaction, while dynamic nesting is achieved by calling a method, which is defined using transactions, within the body of another transaction. Nesting is done under closed nesting semantics as described in \bsref{sec:stm_req_nesting}. An example of nesting using the C\# library is shown in \bsref{lst:library_nesting}. Line 6-15 show a lexically nested transaction, while line 20-24 show two dynamically nested transactions as the \bscode{Enqueue} and \bscode{Dequeue} methods are themselves defined using a transaction. 
%Nesting
\begin{lstlisting}[label=lst:library_nesting,
  caption={Library Nesting},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  public class TransactionExamples {
    
    public static void NestingExample()
    {
      TMVar<string> s = new TMVar<string>(string.Empty);
      var result = STMSystem.Atomic(() =>
      {
        s.Value = "abc";
        STMSystem.Atomic(() =>
        {
          s.Value = s + "def";
        });

        return s.Value;
      });

      Queue<Person> buffer1 = new Queue<Person>();
      Queue<Person> buffer2 = new Queue<Person>();

      STMSystem.Atomic(() =>
      {
        var item = buffer1.Dequeue();
        buffer2.Enqueue(item);
      });
    }
  }
\end{lstlisting}
\subsection{Dining Philosophers as Example}
As a final example employing many of the library features in conjunction, \bsref{lst:library_dinning} presents an implementation of the dining philosophers problem\cite[p. 673]{hoare1978communicating}.  The \bscode{DiningPhilosophers} method on line 3 sets up the required forks and philosophers. The \bscode{StartPhilosopher} method starts a new thread representing a philosopher. The philosopher will first attempt to acquire both forks as defined in the transaction on lines 24-31. If one of the forks is not available, the transaction will execute a retry on line 27, blocking until this state changes. When a philosopher acquires both forks she will eat, represented by the sleep on line 33, followed by putting back the forks in the transaction defined on line 35-39.

\begin{lstlisting}[label=lst:library_dinning,
  caption={Library Dining Philosophers},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block

  public class TransactionExamples {
    
    public static void DiningPhilosophers()
    {
      var fork1 = new TMVar<bool>(true);
      var fork2 = new TMVar<bool>(true);
      var fork3 = new TMVar<bool>(true);
      var fork4 = new TMVar<bool>(true);
      var fork5 = new TMVar<bool>(true);

      StartPhilosopher(fork1, fork2);
      StartPhilosopher(fork2, fork3);
      StartPhilosopher(fork3, fork4);
      StartPhilosopher(fork4, fork5);
      StartPhilosopher(fork5, fork1);
    }

    private static void StartPhilosopher( TMVar<bool> left, TMVar<bool> right)
    {
      var t1 = new Thread(() =>
      {
        while (true)
        {
          STMSystem.Atomic(() =>
          {
            if (!left || !right)
              STMSystem.Retry();

            left.Value = false;
            right.Value = false;
          });

          Thread.Sleep(100); //Eating

          STMSystem.Atomic(() =>
          {
            left.Value = true;
            right.Value = true;
          });

          Thread.Sleep(100); //Thinking
        }
      });

      t1.Start();
    }
  }
\end{lstlisting}

\section{Internal Details}
\label{sec:stm_impl_internal_detials}
This section highlights the defining aspects of the \ac{STM} libraries internal implementation.
\subsection{Writing a Value}
\label{sec:stm_imple_internal_detials_write}
As described in \bsref{sec:stm_impl_tl2}\andreas{Ref to "STM Algorithm?} TL\rom{2} uses a write-set to collect any written values to be written to the actual locations when the transaction commits. Therefore any writes to transactional variables must be redirected to the write-set instead of the actual location. \bsref{lst:library_write_value} shows how this is accomplished in the \ac{STM} library. Line 3 gets the currently executing transaction from threadlocal storage. That is, each thread gets its own transaction instance when accessing the \bscode{LocalTransaction} property. Based on the status of the transaction, different actions are taken. Each thread accesses a transaction that has the status \bscode{Committed} whenever no transaction is currently executing on that specific thread. Therefore the case on line 6 covers writing a value to a transactional variable from outside a transaction scope. How this is accomplished is explained in \bsref{sec:stm_impl_providing_strong_atomicity}. The case on line 9 covers writing a value as part of a transaction. Here the value to be written is put into the write-set of the transaction performing the write. When the given transaction commits, the value will be written back to the transactional variable.

\begin{lstlisting}[label=lst:library_write_value,
  caption={Writing to a Transactional Variable},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block
  
  private void SetValueInternal(T value)
  {
    var me = Transaction.LocalTransaction;
    switch (me.Status)
    {
      case Transaction.TransactionStatus.Committed:
        SetValueNonTransactional(value);
        break;
      case Transaction.TransactionStatus.Active:
        me.WriteSet.Put(this, value);
        break;
    }
  }
\end{lstlisting}

\subsection{Reading a Value}
\label{sec:stm_imple_internal_detials_read}
How the value of a transactional variable is read depends on the context in which the read occurs. Reading the value of a transactional variable from non-transactional code amounts to reading the value contained within the variable, as this value is guaranteed to be the most recently committed value. On the other hand, a read from transactional code has to read an uncommitted value which was previously written by the same transaction, if such a value exists. Only if no such value is present should the transaction read the value currently contained in the transactional variable. \bsref{lst:library_read_value} shows how reading the value of a transactional variable is implemented in the \ac{STM} library. The case on line 6 corresponds to a non-transactional read and are forwarded directly to the base class in order to retrieve the value of the transactional variable. The case on line 8 corresponds to a transactional read. Line 10-13 retrieves a previously written value from the transactions write-set if such a value is present. If no such value is present the value contained in the current transaction is read instead. Finally, on line 15, the transactional variable is added to the active transactions read-set, so that the read can be validated before the transaction commits.
\begin{lstlisting}[label=lst:library_read_value,
  caption={Reading a Transactional Variable},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block
  
  private T GetValueInternal()
  {
    var me = Transaction.LocalTransaction;
    switch (me.Status)
    {
      case Transaction.TransactionStatus.Committed:
        return base.GetValue();
      case Transaction.TransactionStatus.Active:
        T value;
        if (!me.WriteSet.Contains(this))
          value = base.GetValue();
        else
          value = (T)me.WriteSet.Get(this);

        me.ReadSet.Add(this);
        return value;
    }
  }
\end{lstlisting}

\subsection{Committing a Transaction}
Committing a transaction follows the steps described in \bsref{sec:stm_impl_tl2}. \bsref{lst:library_commit} shows the implementations of these steps. The \bscode{Commit} method declared on line 1 drives the commit process and returns \bscode{true} if the commit succeeds. If the transaction is not nested within another transaction, the body of the if statement on line 3 is entered. The call to the \bscode{Validate} method on line 6 acquires the lock on each object in the transactions write-set, validates the read-set and increments the version-clock acquiring the new writestamp. The \bscode{Validate} method returns true if the read-set could be validated correctly and returns the new writestamp using an \bscode{out} parameter. All locks are acquired using a timeout in order to prevent deadlocks and all acquired locks are released if validation of the read-set fails. If validation succeeds the \bscode{HandleCommit} method commits all buffered writes to their respective transactional variables, after which all acquired locks are released. 

If the transaction is nested within another transaction the else case on line 11 is executed. Nested transactions do not need to acquire the lock on items in their read-set or increment the version clock as they will not be responsible for committing the values under closed nested semantics. Therefore, a validation of the read-set, as seen on line 13, is sufficient. If the validation succeeds the transaction merges its read and write sets with those of the outer transaction, in order for the outer transaction to commit any written values when it reaches its commit stage. On line 17 the outer transaction is restored as the currently active transaction so that it can be resumed. Finally on line 20 the status of the transaction is changed to committed, before returning on line 21.


\begin{lstlisting}[label=lst:library_commit,
  caption={Committing a Transaction},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set, bool}]  % Start your code-block
  
  public bool Commit()
  {
    if (!IsNested)
    {
      int writeStamp;
      if (!Validate(out writeStamp))
        return false;

      HandleCommit(writeStamp);
    }
    else
    {
      if (!ValidateReadset())
        return false;

      MergeWithParent();
      Transaction.LocalTransaction = Parent;
    }

    Status = TransactionStatus.Committed;
    return true;
  }
\end{lstlisting}

\subsection{Providing Strong Atomicity}
\label{sec:stm_impl_providing_strong_atomicity}
As described in \bsref{sec:stm_requirements} the \ac{STM} system must support strong atomicity. In \bsref{sec:stm_imple_internal_detials_write} and \bsref{sec:stm_imple_internal_detials_read} it is described how the \ac{STM} system is able to detect whether or not read and write operations occur inside or outside a transaction and take different actions based on this information. In the case of a non-transactional read the system reads the most recently committed value as described in \bsref{sec:stm_imple_internal_detials_read}, ensuring that no uncommitted values can be read. A non-transactional write is more complicated as the \ac{STM} system must ensure atomicty between both non-transactional access and transactional access. To that extent the approach described by Hindman et al. in \cite{hindman2006atomicity} of executing non-transactional access as optimized mini transaction is adopted. As no value is read during a non-transactional write, a non-transactional write in the context of the TL\rom{2} algorithm consist only of 
\begin{inparaenum}[(1)]
\item Acquiring the lock on the transactional variable to which the write occurs
\item Incrementing and getting the value of the version clock
\item Committing the new value and timestamp
\item Releasing the acquired lock,
\end{inparaenum}
any access to the read-set can be optimized away. The \ac{STM} library implements this approach in the \bscode{SetValueNonTransactional} method of the \bscode{TMVar<T>} class shown in \bsref{lst:library_non_trans_write}.
\begin{lstlisting}[label=lst:library_non_trans_write,
  caption={Non-transactional Write},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block
  
  private void SetValueNonTransactional(T value)
  {
    Lock();
    Commit(value, VersionClock.IncrementClock());
    Unlock();
  }
\end{lstlisting}

\subsection{Providing Opacity}
As described in \bsref{sec:stm_req_opacity} providing opacity requires ensuring that transactions do not read invalid data throughout their execution. Therefore a transaction must validate a read when it occurs, ensuring that the transaction is not allowed to continue when the read is inconsistent. For this purpose the \ac{STM} library uses the approach shown by \cite[p. 117]{harris2010transactional} and extends the reading of values to the implementation depicted in \bsref{lst:library_opacity}. As seen on lines 12-16, reading a value directly from the transactional variable has been extended with validation that ensures the transaction aborts if the variable has been changed since the transaction recorded its timestamp. The timestamp of the transactional variable prior to reading it is stored locally on line 12. After the variable has been read the locally cached timestamp is compared to the current timestamp of the transactional variable and the timestamp of the current transaction. If the timestamp was changed during the read or the cached timestamp is higher than the timestamp of the current transaction, the current transaction is aborted by throwing a \bscode{STMAbortException} on line 16.
\begin{lstlisting}[label=lst:library_opacity,
  caption={Providing Opacity},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var, get, set}]  % Start your code-block
  
  private T GetValueInternal()
  {
    var me = Transaction.LocalTransaction;
    switch (me.Status)
    {
      case Transaction.TransactionStatus.Committed:
        return base.GetValue();
      case Transaction.TransactionStatus.Active:
        T value;
        if (!me.WriteSet.Contains(this))
        {
          var preStamp = TimeStamp;
          value = base.GetValue();

          if (IsLocked() || preStamp != TimeStamp ||  me.ReadStamp < preStamp)
            throw new STMAbortException("Aborted due to inconsistent read");
        }
        else
          value = (T)me.WriteSet.Get(this);

        me.ReadSet.Add(this);
        return value;
    }
  }
\end{lstlisting}

\section{Testing}
\label{sec:stm_impl_testing}
In order to ensure that the \ac{STM} library executes transactions according to the requirements defined in \bsref{sec:stm_requirements}, a number of tests have been created.

An improvisational approach for testing is to create some ad hoc throw-away code\cite[Chap. 9]{martin2008clean} and manually interacting with the program, to ensure some code works correctly. This approach has the advantage that tests can be created quickly and errors found quickly. However the approach has the disadvantages that it is unstructured and the testing can not be rerun automatically, so if a later change damages a feature which has previously been tested as working correctly, this will not be discovered. 

Another more structured approach is to use unit testing\cite{fowlerUnitTesting}, where tests are structured into unit tests, which only focus on the correctness of a small part of the program. Furthermore, unit testing is often automated, so they can easily be rerun to ensure the unit they test still works correctly. A drawback with this approach is that it is more time consuming to setup than adhoc testing.

As unit testing will allow for automatic testing of new features not breaking existing functionality, unit testing has been selected for testing the \ac{STM} library. The defined tests cover areas such as the execution of transactions, nesting, retry, orelse, strong atomicity and exceptions in transactions. Additionally, a number of tests based on a transactional queue and hashmap implementation has been created. Where the first set of test cover smaller parts of the \ac{STM} library the second set of tests cover the \ac{STM} library as a whole, ensuring that the library can be utilized for real world scenarios.

In addition a number of tests, which attempt to produce a result which can only occur when a race condition is present, has been created. While such tests can ultimately not prove that no race conditions are present, they do provide a degree of certainty that this is the case. \bsref{lst:stm_race_test} shows the \bscode{RaceTest1} method conducting a test for possible race conditions. \bscode{RaceTest1Internal} is called 10000 times producing a result for each iteration. Line \ref{line:stm_test_assert} assert that each result is not the result a race condition in \bscode{RaceTest1Internal} would produce. \bscode{RaceTest1Internal} executes a read modify write operation on one thread, while another thread writes to the same variable. The call to \bscode{Thread.Yield} on line \ref{line:stm_test_yield} signals the underlying system that \bscode{t1} can be descheduled in favor of other threads, allowing \bscode{t2} to assign \bscode{result} a new value after \bscode{t1} has read the value of result, but before it has computed and assigned the new value. \bscode{Thread.Yield} does not cause \bscode{t1} to be desheduled in all cases, only when the underlying scheduling determines that it is appropriate. 

\begin{lstlisting}[label=lst:stm_race_test,
  caption={RaceTest1},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapechar=~,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orelse, var, get, set, ref, out, Test}]  % Start your code-block
  
  [TestMethod]
  public void RaceTest1()
  {
    for (int i = 0; i < 10000; i++)
    {
      var result = RaceTest1Internal();
      Assert.IsTrue(result != 120);~\label{line:stm_test_assert}~
    }
  }

  private int RaceTest1Internal()
  {
    var result = new TMVar<int>(10);

    var t1 =  new Task(() =>
    {
      STMSystem.Atomic(() =>
      {
        if (result.Value == 10)
        {
          Thread.Yield();~\label{line:stm_test_yield}~
          result.SetValue(result.Value * 10);
        }
      
        return result.GetValue();
      });
    });

    var t2 = new Task(() => STMSystem.Atomic(() => 
    {
      result.Value = 12;
    }));

    t1.Start();
    t2.Start();
    t1.Wait();
    t2.Wait();

    return result.Value;
  }
\end{lstlisting}

%\kasper[inline]{obstruction freedom useful in practice}
%\kasper[inline]{pending commit, permissiveness}
%\andreas[inline]{Analysis of privatization techniques is done by \cite{spear2007privatization}. Strong atomicity is the technique with less restrictions, but worst performance}
%\andreas[inline]{Strong atomicity can be optimized via compile time optimizations and obtain good performance. Key is removing barriers cite \cite{hindman2006atomicity}}
%\andreas[inline]{In some cases, the order of reading values must be enforced. The compiler will reorder the value readings, and the volatile keyword must be used to enforce no optimizations from the compiler. Example \cite[p. 35]{harris2010transactional}}.
%\andreas[inline]{We must handle interoperation with binaries using our library. They will be translated, and not annotated with atomic keywords. We must accommodate this when designing the compiler, to ensure interaction with atomicsharp works.}
\andreas[inline]{C\# memory model is weak. We must use locks to enforce read/write order. This is another argument for not using a lock-free algorithm.}
\worksheetend